{"meta":{"title":"无限Coding","subtitle":null,"description":null,"author":"infinitor","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"数据结构-线性表|顺序表|链表(中)","slug":"数据结构-线性表-顺序表-链表-中","date":"2018-02-18T05:19:16.000Z","updated":"2018-02-18T05:19:55.802Z","comments":true,"path":"2018/02/18/数据结构-线性表-顺序表-链表-中/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-线性表-顺序表-链表-中/","excerpt":"","text":"数据结构-线性表|顺序表|链表(中)本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list)03 单链表(Singly Linked List )3.1 什么是单链表？单链表是一种链式存储的结构。它动态的为节点分配存储单元。当有节点插入时，系统动态的为结点分配空间。在结点删除时，应该及时释放相应的存储单元，以防止内存泄露。由于是链式存储，所以操作单链表时，必须知道头结点或者头指针的位置。并且，在查找第i个节点时，必须找到第i-1个节点。 3.2 单链表的存储结构代码描述对于链式存储，通过上一节的讲解相信大家已经了解得够清楚了。如下图所示： 下面我们来看看单链表存储是如何用代码来实现的。123456//单链表的存储结构C语言代码typedef struct SListNode&#123; datatype data; //数据域 struct SListNode * pnext;//指针域&#125;SLinkList; 由上面的结构我们可以看出，一个节点由存放数据的数据域和存放地址的指针域组成。假如p指向了第i个节点，那么p-&gt;data就是该节点存放的数据，而p-&gt;pnext自然就是指向下一个节点的指针。如下图所示： 那么接下来我们看看单链表的各个操作具体实现吧。(只讲几个关键步骤)备注：下面的代码基于这样的一个单链表： 有一个头指针phead 有一个头结点node 头指针指向头结点，头结点位置记为03.3 单链表的读取在拿到头指针以后，单链表的读取也并非一件难事。一开始设置一个计数变量，不断遍历链表，让计数器自增。找到合适的位置将数据读取出来。具体代码实现如下：12345678910111213141516171819202122232425262728#define status bool#define ERROR false#define OK true/* * 函数功能：获取位置index节点的数据 * 参数说明：phead链表头结点，e用来获取的变量，index索引*/status GetSListIndexNode(Node * phead,DType *e, int index)&#123; int icount = 0; //计数器 //注：0号位为头结点，头结点不存放任何数据 if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()/*此处为链表长度*/) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; icount++; phead = phead-&gt;pnext; if (icount == index) &#123; *e = phead-&gt;data; return OK; &#125; &#125; return ERROR;&#125; 3.4 单链表的插入3.4.1 指定位置后插其实链表的插入和删除都是很简单的操作，初学者只要抓住指针指向的节点，并加以区分开来，就很easy了。如下图： 图中，假如此时p指向了我们要插入的节点的位置。那么，怎样把我们的S节点给插入到p指向的节点之后？在这里我们先不要惊动p以及p后面的节点： 我们先让S节点指向p之后的节点(步骤①) 之后我们切断p和p后面那个节点的关系(步骤②) 最后让p节点的指针域指向s节点(步骤③)，搞定 算法描述： 声明一个指针p指向链表头结点，向后遍历p=p-&gt;next，找到正确的位置。 新建一个结点s。 s-&gt;next = p-&gt;next ① p-&gt;next = s ②③具体代码如下：12345678910111213141516171819202122232425262728293031#define status bool#define ERROR false#define OK true/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData插入的数据，index索引*/status InsertSListNodeFront(Node * phead, DType IData, int index)&#123; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if ( iCount == index ) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125; 3.4.1 指定位置前插咳咳，聪明的小伙伴，用脑子想想。指定位置前插 == 指定位置的前一个位置进行后插。懂了吧？直接看具体代码：123456789101112131415161718192021222324252627282930/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData插入的数据，index索引*/status InsertSListNodeBack(Node * phead, DType IData, int index)&#123; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = phead; phead = phead-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125; 3.5 单链表的删除单链表的删除其实也是很简单。只要比如要删除p指向的节点，只需要让p之前的节点的指针域直接指向p之后的节点，再把p给free就OK了。如下图： 算法描述: 声明一个指针p指向链表头结点，向后遍历p=p-&gt;next，找到要删除的节点位置。 q = p-&gt;next p-&gt;next = q-&gt;next ①② free(q) ③④ 具体代码如下:12345678910111213141516171819202122232425262728/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData获取删除的数据，index索引*///删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status DeleteSListIndexNode(Node * phead, DType *e, int index)&#123; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; q = phead; //保存备用 phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; q-&gt;pnext = phead-&gt;pnext; //删除出局 return OK; &#125; &#125; return ERROR;&#125; 代码应该不难，相信大家都能很容易看懂。 3.6 单链表的完整代码好了，前面介绍了几个重要的操作，接下来请大家看看完整的代码吧。小编为了使用方便，就用C++的class和template将整个链表封装到了一个类里面，通过模板实现泛型编程。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415/* * 文件名:SingleLinkList.h * 说明 ：类的各种声明 */#pragma once //VC编译器防止头文件被重复包含的一条预编译指令#define status bool#define OK true#define ERROR false#define YES true#define NO falsetemplate &lt;typename DType&gt;class Node&#123;public: DType data; Node * pnext;&#125;;template &lt;typename DType&gt;class CSingleLinkList&#123;private: Node&lt;DType&gt; *phead; //链表头指针public: CSingleLinkList();//构造，类被创建时调用 ~CSingleLinkList();//析构，类被销毁时调用public: //初始化链表 status InitSList(); //获取链表长度 int GetSListLength(); //增加一个节点 前插法 status AddSListNodeFront(DType idata); //增加一个节点 后插法 status AddSListNodeBack( DType idata); //判断链表是否为空 status IsSListEmpty(); //获取指定位置节点值(注意，本程序规定0号为头节点，e获取删除元素) status GetSListIndexNode(DType *e, int index); //删除指定位置节点(e获取删除元素) status DeleteSListIndexNode(DType *e, int index); //查找链表中指定值(pindex获取位置0==&gt;not found) status SearchSListNode(DType SData, int *pindex); //指定位置前插 status InsertSListNodeFront(DType IData, int index); //指定位置后插 status InsertSListNodeBack(DType IData, int index); //清空链表(保留根节点) status ClearSList(); //销毁链表(all delete) status DestorySList(); //尾部删除一个元素 status DeleteSListNodeBack(); //打印链表 此函数根据实际情况而定 void PrintSList();&#125;;/* * 文件名:SingleLinkList.cpp * 说明 ：类的各种方法的实现 */#include \"SingleLinkList.h\"#include &lt;stdio.h&gt;template &lt;typename DType&gt;CSingleLinkList&lt;DType&gt;::CSingleLinkList()&#123; cout &lt;&lt; \"链表创建\" &lt;&lt; endl; InitSList();&#125;template &lt;typename DType&gt;CSingleLinkList&lt;DType&gt;::~CSingleLinkList()&#123; cout &lt;&lt; \"链表销毁\" &lt;&lt; endl; DestorySList();&#125;//初始化链表template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InitSList()&#123; Node&lt;DType&gt; * ph = new Node&lt;DType&gt;; if (ph != NULL) &#123; ph-&gt;pnext = nullptr; this-&gt;phead = ph; //头结点 return OK; &#125; return ERROR;&#125;//获取链表长度(head_node is not included)template &lt;typename DType&gt;int CSingleLinkList&lt;DType&gt;::GetSListLength()&#123; int length = 0; Node&lt;DType&gt; * phead = this-&gt;phead; while (phead-&gt;pnext != nullptr) &#123; length++; phead = phead-&gt;pnext; &#125; return length;&#125;//增加一个节点 前插法template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::AddSListNodeFront( DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; if (pnode != NULL) &#123; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead-&gt;pnext; this-&gt;phead-&gt;pnext = pnode; //挂载 //printf(\"pnode = %p pnode-&gt;pnext = %p this-&gt;phead-&gt;pnext = %p this-&gt;phead = %p\\n\", pnode, pnode-&gt;pnext, this-&gt;phead-&gt;pnext, this-&gt;phead); return OK; &#125; return ERROR;&#125;//增加一个节点 尾插法template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::AddSListNodeBack(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; Node&lt;DType&gt; * phead = this-&gt;phead; if (pnode != NULL) &#123; while (phead-&gt;pnext != nullptr) &#123; phead = phead-&gt;pnext; &#125; pnode-&gt;data = idata; pnode-&gt;pnext = nullptr; phead-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//判断链表是否为空template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::IsSListEmpty()&#123; if (this-&gt;phead-&gt;pnext == nullptr) &#123; return YES; &#125; return NO;&#125;//获取指定位置节点值(注意，本程序规定0号为头节点，e获取节点的值)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::GetSListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int i = 0; //计数器 if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; return OK; &#125; &#125; return ERROR;&#125;//删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DeleteSListIndexNode( DType *e, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; q = phead; //保存备用 phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; q-&gt;pnext = phead-&gt;pnext; //删除出局 return OK; &#125; &#125; return ERROR;&#125;//查找链表中指定值(pindex获取位置 0==&gt;not found)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::SearchSListNode( DType SData, int *pindex)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int iCount = 0;//计数器 while (phead-&gt;pnext != nullptr) &#123; iCount++; phead = phead-&gt;pnext; if (phead-&gt;data == SData) &#123; *pindex = iCount; return YES; &#125; &#125; *pindex = 0; return NO;&#125;//指定位置前插template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InsertSListNodeFront(DType IData, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if ( iCount == index ) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125;//指定位置后插template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InsertSListNodeBack( DType IData, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = phead; phead = phead-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125;//清空链表(保留根节点)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::ClearSList()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //防止那啥，野指针 phead = phead-&gt;pnext;//保留头节点 while (phead != nullptr) &#123; q = phead; phead = phead-&gt;pnext; delete q; //释放 &#125; this-&gt;phead-&gt;pnext = nullptr; return OK;&#125;//销毁链表(all delete)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DestorySList()&#123; ClearSList(); delete this-&gt;phead;//释放头结点 return OK;&#125;template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DeleteSListNodeBack()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //备用 if (phead-&gt;pnext == nullptr) &#123; return ERROR; //链表都空了还删鸡毛 &#125; while (phead-&gt;pnext != nullptr) &#123; q = phead; phead = phead-&gt;pnext; &#125; q-&gt;pnext = nullptr; delete phead; return OK; &#125;template &lt;typename DType&gt;void CSingleLinkList&lt;DType&gt;::PrintSList()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || phead == nullptr) &#123; cout &lt;&lt; \"链表为空，打印鸡毛\" &lt;&lt; endl; return; &#125; int i = 1; cout &lt;&lt; \"===============print list================\" &lt;&lt; endl; while (phead-&gt;pnext != nullptr) &#123; phead = phead-&gt;pnext; cout &lt;&lt;\"node[\" &lt;&lt; i++ &lt;&lt; \"] = \" &lt;&lt; phead-&gt;data&lt;&lt;endl; &#125;&#125;/* * 文件名:SingleLinkListTest.cpp * 说明 ：测试代码 */ #include &lt;iostream&gt;#include \"SingleLinkList.h\"#include \"SingleLinkList.cpp\"using namespace std;int main()&#123; CSingleLinkList&lt;int&gt; * pMySList = new CSingleLinkList&lt;int&gt;; cout &lt;&lt; pMySList-&gt;IsSListEmpty() &lt;&lt; endl; pMySList-&gt;AddSListNodeFront(111); pMySList-&gt;AddSListNodeFront(222); pMySList-&gt;AddSListNodeFront(333); cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetSListLength() &lt;&lt; endl; pMySList-&gt;PrintSList(); pMySList-&gt;AddSListNodeBack(444); pMySList-&gt;AddSListNodeBack(555); pMySList-&gt;AddSListNodeBack(666); pMySList-&gt;PrintSList(); cout &lt;&lt; pMySList-&gt;IsSListEmpty() &lt;&lt; endl; cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetSListLength() &lt;&lt; endl; int GetElem, GetIndex; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 2); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 6); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 4); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteSListIndexNode(&amp;GetElem, 1); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteSListIndexNode(&amp;GetElem, 3); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;PrintSList(); pMySList-&gt;SearchSListNode(555, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchSListNode(111, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchSListNode(666, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;InsertSListNodeFront(333, 1); pMySList-&gt;InsertSListNodeFront(444, 4); pMySList-&gt;PrintSList(); pMySList-&gt;InsertSListNodeBack(777, 3); pMySList-&gt;InsertSListNodeBack(888, 5); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); return 0;&#125;代码如果有不正确的地方，欢迎大家来指正哈。 04 静态链表(circular linked list)4.1 什么是静态链表？我们把线性表的元素存放在数组中，这些元素由两个域组成： 数据域data 指针域cur 数据域是存放数据的，而指针域，这里和链表不同是，它存的不再是指向下一个节点的内存地址。而是下一个节点在数组中的下标。我们就把这种用数组描述的链表称为静态表，该方法也称之为游标实现法。如下图所示： 由上图我们需要注意以下几点： 我们对数组的第一个元素和最后一个元素做特殊处理，不存放数据。 把未使用的数组元素称为备用链表。 数组的第一个元素(下标为0)的cur域存放备用链表第一个节点的下标。 数组的最后一个元素的cur域存放第一个有数据的节点的下标，相当于链表中头结点的存在。链表为空时，其值为0。 如下图： 引出的问题：数组的长度定义的问题，无法预支。所以，为了防止溢出，我们一般将静态表开得大一点。 4.2 静态链表存储的代码描述基于上面的讲解，我们来看看代码是怎么描述这种存储结构的。1234567//---------线性表的静态单链表存储结构--------#define MAXSIZE 1000 /*假设链表最大长度为1000*/typedef struct&#123; datatype data; int cur; //为0时表示无指向&#125;SLinkList[MAXSIZE]; 接下来我们讲解几个重要的操作实现。 4.3 静态链表的插入操作前面我们讲动态链表的时候说过，增加和删除一个节点我们可以用malloc()和free()函数(C++可用new和delete)来实现。但是现在由于我们操作的是静态表，它可是用数组存的，可没有这种操作了。因此我们首先来自己实现一个静态表的malloc和free。 那么怎么辨别数组中哪些空间没有被使用呢？一个好的解决办法是，将所有未使用或者被删除的空间串成一个备用链表。插入节点时便可以从备用链表获取第一个未使用的空间的下标。因此我们在初始化的时候会做这样的工作： 12345678910void SListInit(SLinkList space)&#123; int i; for(i = 0; i &lt; MAXSIZE; i++) space[i].cur = i+1; //将所有结点链入备用链表 //备用链表头指针链像第二个结点 space[0].cur = space[1].cur; //第一个结点作为链表的头结点 space[1].cur = 0; &#125; 分配内存123456789101112/分配备用链表的一个结点,返回下标//若为0，则说明备用链表用完int Malloc_SL(SLinkList space)&#123; int i = space[0].cur; //判断备用链表是否非空 if(space[0].cur) //备用链表头指针指向第二个空结点 space[0].cur = space[i].cur; return i; //返回第一个空结点&#125; 上面的代码应该是没有难度的。写完了这个函数，我们来看看静态表中具体如何插入：12345678910111213141516171819//在链表的第i个位置插入元素evoid SlistInsert(SLinkList space, int i, ElemType e)&#123; //超出范围 if(i &lt; 1 || i &gt; SListLength(space)+1) return; int k = 1, j; //使k指示要插入的结点的前一个结点 for(j = 0; j &lt;i-1; j++) k = space[k].cur; int v = Malloc_SL(space); if(v) //如果有空间 &#123; space[v].data = e; space[v].cur = space[k].cur; space[k].cur = v; //链入链表 &#125;&#125; 注意几点： 首先我们让k指向了要插入节点(记为X)的前一个位置(记为Y节点)，前插法。 然后我们在静态表内申请空间，存放新的节点(记为N)。 把数据放进新申请的节点里面。 新节点N的cur域指向X节点，然后让Y节点指向N节点。 该过程不难理解。就不上图了…… 4.4 静态链表的删除操作删除同样需要自己实现free函数，我们来看看代码： 回收内存12345678//将下标为k的空闲结点回收到备用链表void Free_SL(SLinkList space, int k)&#123; //将备用链表链到k之后 space[k].cur = space[0].cur; //将k链到备用链表头之后 space[0].cur = k; &#125; 删除以后记得把空间重新挂载到备用链表上以便下一次使用。下面我们实现删除的代码： 1234567891011121314//删除第i个位置的元素void SListDelete(SLinkList space, int i)&#123; //超出范围退出 if(i &lt; 1 || i &gt; SListLength(space)) return ; int k = 1, j; //使k指示要删除的结点的前一个结点 for(j = 0; j &lt;i-1; j++) k = space[k].cur; int temp = space[k].cur; space[k].cur = space[temp].cur; Free_SL(space, temp);&#125; 其实代码也很好理解了。假如X、Y、Z……等等排列，我们要删除Y。无非就是告诉X，你不要指向Y了，你直接指向Z，然后我们再把Y给free了。就直接变成了X、Z……简单吧。 4.5 静态链表的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/************************************* 静态链表数据结构：每个数组节点都有值和游标.游标表示下一个节点，节点分为已用节点和备用节点第一个节点和最后节点保留：第一个节点游标表示备用节点起始位置最后一个节点游标表示已用节点的起始位置已用节点的最后一个元素的游标指向0，表示末尾。*************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define ERROR 0#define OK 1#define MAX 100 //声明数组的最大长度typedef int Status,ElemType;typedef struct&#123; int data; //数据 int cur; //游标&#125;component,staticlink[MAX]; //定义结构体数组/********************************** 初始化链表输入值：链表的指针输出值：状态码功能： 将所以节点的游标指向后一个节点 ***********************************/Status initLink(staticlink space)&#123; int i; for(i=0;i&lt;(MAX-1);i++)&#123; //遍历所有节点 space[i].cur = i+1; //将节点的游标指向下个节点 &#125; space[MAX-1].cur = 0; //最后一个节点的游标指向第一个节点 return OK;&#125;/********************************* 分配备用空间输入值：链表的指针输出值：备用节点的下标功能： 将备用节点的分配出来使用 *********************************/int mallocSpace(staticlink space)&#123; int i; i = space[0].cur; //取出第一个备用节点 if(space[0].cur) //如果取出成功 space[0].cur = space[i].cur; //第一个节点的指针往后移动 return i;&#125;/******************************** 获取长度输入值：链表的指针输出值：长度值功能： 将链表中已用的节点个数返回 ********************************/int getLength(staticlink space)&#123; int mov = MAX-1; int j=0; while(space[mov].cur) &#123; //遍历所有已用节点 mov = space[mov].cur; j++; &#125; return j;&#125;/********************************* 创建值输入值：链表的指针，初始值个数输出值：状态码功能： 为链表初始指定个数的随机值 *********************************/Status createValue(staticlink space,int num)&#123; srand(time(0)); int i,mov = MAX-1; space[mov].cur = 1; for(i=0;i&lt;num;i++) &#123; mov = space[mov].cur; //移动游标 space[mov].data = rand()%100+1; //初始化随机值 &#125; space[0].cur = space[mov].cur;//第一节点游标指向备用节点 space[mov].cur = 0; //最后一个已用节点指向第一个节点 return OK;&#125;/********************************* 插入节点输入值：链表的指针，插入位置(从1开始)，插入位置输出值：状态码功能： 在指定的位置插入指定的值 *********************************/Status insertNode(staticlink space,int index,ElemType e)&#123; int new,mov,i; if(index&lt;1 || index&gt;getLength(space))return ERROR; //不可以超过已用节点个数 mov = MAX-1; new = mallocSpace(space); if(new)&#123; space[new].data=e; //创建新节点 for(i=1;i&lt;index;i++)//定位插入节点的前一节点 mov = space[mov].cur; space[new].cur = space[mov].cur; //连后 space[mov].cur = new; //接前 return OK; &#125; return ERROR;&#125;/************************************ 删除节点输入值：链表的指针，删除位置(从1开始)输出值：状态码功能： 删除指定的节点 ************************************/Status deleteNode(staticlink space,int index)&#123; if(index&lt;1 || index&gt;getLength(space))return ERROR; int mov,next,i; mov = MAX-1; for(i=1;i&lt;index;i++) //定位删除节点的前一节点 mov = space[mov].cur; next = space[mov].cur;//获取被删节点 space[mov].cur = space[next].cur; //前一节点连接被删节点的游标 freeNode(space,next);//释放被删节点 return OK;&#125;/*********************************** 释放节点输入值：链表的指针，释放节点的位置输出值：状态码功能: 将已用节点释放成备用节点 ***********************************/Status freeNode(staticlink space,int target)&#123; space[target].cur = space[0].cur;//释放节点连接第一备用节点 space[0].cur = target;//第一节点连接释放节点 return OK;&#125;/********************************** 输出链表输入值：链表的指针输出值：状态码功能： 将链表的值一一输出 **********************************/Status printLink(staticlink space)&#123; int mov = MAX-1; while(space[mov].cur) &#123; mov = space[mov].cur; printf(\"[%d] \",space[mov].data); &#125; printf(\"\\n\"); return OK;&#125;int main()&#123; int num,value,index; staticlink L; initLink(L); printf(\"[create]enter num:\"); scanf(\"%d\",&amp;num); createValue(L,num); printLink(L); printf(\"[insert]enter index:\"); scanf(\"%d\",&amp;index); printf(\"[insert]enter value:\"); scanf(\"%d\",&amp;value); insertNode(L,index,value); printLink(L); printf(\"[delete]enter index:\"); scanf(\"%d\",&amp;index); deleteNode(L,index); printLink(L); return 0; 这次就先到这里吧。更多精彩内容，请期待下回分解。 另外：部分资料参考自网络，来源和作者实在无法考证，如果有侵犯到您的劳动成果，请速与我联系。 ========================END=======================","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-线性表|顺序表|链表(上)","slug":"数据结构-线性表-顺序表-链表-上","date":"2018-02-18T05:14:40.000Z","updated":"2018-02-18T05:17:28.301Z","comments":true,"path":"2018/02/18/数据结构-线性表-顺序表-链表-上/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-线性表-顺序表-链表-上/","excerpt":"","text":"本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list) 01 预备知识1.0 什么是线性表?线性表(List)是零个或者多个数据元素的有限序列. 首先它是一个序列.里面的元素是有顺序的,如果有多个元素,除开头和结尾以外的元素都有一个前驱和一个后继.而开头元素只有后继,结尾元素只有前驱. 其次线性表是有限的，也就是里面的元素个数是有限的。 1.1 线性表的基本操作(描述)12345678910111213ADT 线性表（List）Data 线性表的数据对象集合为&#123;a1, a2, a3, ......, an&#125;,每个元素类型为DataType。Operation InitList(L); //初始化线性表 IsEmptyList(L); //判断线性表是否为空 ClearList(L); //清空线性表 GetElemList(L, i, *e); //获取第i个位置的数据 SearchList(L, e); //查找与数据e相等的元素 InsertNodeList(L, i, e);//在第i个位置插入元素 DeleteNodeList(L, i, *e);//删除第i个位置的元素，e获取删除元素 GetLengthList(L); //获取线性表的长度endADT 关于线性表的基本操作就上面几种，还有几个例如线性表的排序，合并，逆序等等操作。为了文章篇幅，就下次再介绍了。 1.2 什么是顺序存储结构?线性表的顺序存储结构，就是指 用一段地址连续的存储单元一次存储线性表的数据元素。学过高级语言的朋友，相信对数组这玩意儿都不会陌生吧。数组就是一种顺序存储结构。 1.3 什么是链式存储结构?链式存储结构就是可以用一组任意的内存单元存储线性表中的元素。与顺序存储不同的是，这组内存单元可以是连续的，也可以是不连续的。这就意味着，元素可以存储在内存的任意位置。正因为如此，在链式结构中，每个元素不仅要存它的信息，还需要存储它后继元素的存储地址。我们把存储元素信息的域称为数据域，而把存储后继元素地址的域称为指针域。由这两部分共同组成的数据元素ai，则可以称之为节点(Node)。如下面这个图所示： 1.5 什么是链表?链表就是链式存储的线性表。结点之间通过逻辑连接，形成链式存储结构。存储结点的内存单元，可以是连续的也可以是不连续的。逻辑连接与物理存储次序没有关系。 02 顺序表(Sequential List)2.0 什么是顺序表? 采用顺序存储结构的线性表，就是顺序表。 2.1 顺序表的存储结构代码这里我们统一采用C语言来描述。1234567#define MAXSIZE 20 //存储空间的初始大小typedef int DataType //类型可根据实际情况而定typedef struct &#123; DataType data[MAXSIZE]; //数组来存储数据 int length; //实际长度&#125;SqlList; 可见，顺序表的几个重要特性： 存储空间的位置：数组data 顺序表的最大容量：数组长度MAXSIZE 顺序表当前长度：length 2.2 顺序表的插入操作相信大家在排队的时候都有过被插队的体验吧。当一个插队到你前面时，这个时候你内心os mmp外加素质三连的同时，也不得不往后挪一个位置。于是乎这个就不得了了，你后面的也要往后挪，你后面的后面也是……然后队伍里瞬间就狼烟起……那么，这个顺序表的插入其实也差不多的。由于地址是连续存储的，那么在某个地方插入以后，其后的元素不得不往后挪一个位置。 插入算法描述： 异常处理(插入位置不合理、顺序表已经满等等)。抛出异常。 从最后一个元素往前遍历到第i个位置，依次将他们都往后挪一个位置。 将要插入的元素放入位置i处。 别忘记了表长度length++。 由于数组下标是从0开始的，我们习惯要删除的位置第i处又是从1开始算起的。本文就全部统一成，都从0开始吧。比如要在第5个位置插入一个元素，那就是a[5]。不然真的会混乱的。 具体代码如下：1234567891011121314151617//功能：在顺序表L第i个位置之前插入元素eint InsertSqlList(SqlList *L, int i, DataType data)&#123; int k; if(L-&gt;length==MAXSIZE || i&lt;0 || i&gt;L-&gt;length) //记住，都是从0开始的哦 return 0;//异常处理 if(i == L-&gt;length) L-&gt;data[length++] = data;//尾插一步到位 if(i &lt; L-&gt;length) //中间插，要挪人啦 &#123; for(k = L-&gt;length-1; k &gt;= i;k--) //再次强调哈，都是从0开始的。 L-&gt;data[k+1]=L-&gt;data[k];//后移 L-&gt;data[i] = data;//新元素插入 L-&gt;length++; &#125; return 1;&#125; 2.2 顺序表的删除操作算法描述： 异常处理(删除位置不合理、顺序表为空等等) 尾删，直接获取然后length–。 中间删，从i开始往后遍历，依次将各元素往前挪。e获取要删元素，length–即可。12345678910111213141516171819//功能：在顺序表L中删除第i个数据元素，用e获取被删除值int DeleteElemList(SqlList *L, int i, DataType *e)&#123; int k; if(L-&gt;length==0 || i&lt;0 || i&gt;L-&gt;length-1) //记住，都是从0开始的哦 return 0;//异常处理 if(i == L-&gt;length-1) //尾删，easy &#123; *e = L-&gt;data[i];//获取要删除元素 L-&gt;length--; //删除元素 &#125; if(i &lt; L-&gt;length) //中间删，要挪人啦 &#123; *e = L-&gt;data[i];//获取要删除元素 for(k = i; k &lt; L-&gt;length-1;k++) //再次强调哈，都是从0开始的。 L-&gt;data[k]=L-&gt;data[k+1];//前移 L-&gt;length--; return 1; &#125; 2.3 顺序表的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 20#define ERROR 0#define OK 1#define NO 0#define YES 1typedef int DataType;typedef int Status;typedef struct List&#123; int data[MAXSIZE]; int length;&#125;SqlList;void InitList(SqlList * L); //初始化顺序表Status IsEmptyList(SqlList *L); //判断顺序表是否为空void ClearList(SqlList *L); //清空线性表Status GetElemList(SqlList *L,int i,DataType *e); //获取第i个位置的数据int SearchList(SqlList *L, DataType e); //查找与数据e相等的元素Status InsertNodeList(SqlList *L, int i,DataType e);//在第i个位置插入元素Status DeleteNodeList(SqlList *L, int i, DataType *e);//删除第i个位置的元素，e获取删除元素int GetLengthList(SqlList *L); //获取线性表的长度void PrintList(SqlList *L); //遍历顺序表,此函数测试使用，根据实际类型编写int main()&#123; int e; SqlList *pL = (SqlList*)malloc(sizeof(SqlList)); InitList(pL); InsertNodeList(pL, 0, 1); InsertNodeList(pL, 1, 2); InsertNodeList(pL, 2, 3); InsertNodeList(pL, 3, 4); InsertNodeList(pL, 4, 5); InsertNodeList(pL, 5, 6); PrintList(pL); DeleteNodeList(pL, 2, &amp;e); DeleteNodeList(pL, 4, &amp;e); PrintList(pL); return 0;&#125;void InitList(SqlList * L)&#123; for(int i = 0; i &lt; MAXSIZE; i++) L-&gt;data[i] = 0; L-&gt;length = 0; //将表设为空&#125;Status IsEmptyList(SqlList *L)&#123; if(L-&gt;length == 0) return YES;//表为空 else return NO;&#125;void ClearList(SqlList *L)&#123; InitList(L);//此操作跟初始化一样。&#125;//这里的第i个位置，为了统一我们也是从0算起的Status GetElemList(SqlList *L,int i,DataType *e)&#123; if(i &lt; 0 || i &gt;= L-&gt;length || L-&gt;length == 0) return ERROR;//异常处理 *e = L-&gt;data[i]; return OK;&#125;//找到与数据e相同的节点，返回下标。-1表示没找到,ERROR表示表为空int SearchList(SqlList *L, DataType e)&#123; if(L-&gt;length == 0) return ERROR; for(int i = 0; i &lt; L-&gt;length; i++) &#123; if(L-&gt;data[i] == e) return i; &#125; return -1;&#125;//获取顺序表的长度int GetLengthList(SqlList *L)&#123; return L-&gt;length;&#125;//在位置i插入元素，再次强调，从0开始Status InsertNodeList(SqlList *L, int i,DataType e)&#123; if(i &lt; 0 || i &gt; L-&gt;length || L-&gt;length == MAXSIZE) return ERROR;//异常处理 for(int k = L-&gt;length; k &gt; i; k--) &#123; L-&gt;data[k] = L-&gt;data[k-1]; //往后挪 &#125; L-&gt;data[i] = e;//插入数据， L-&gt;length++; //长度也要加1 return OK;&#125;Status DeleteNodeList(SqlList *L, int i, DataType *e)&#123; if(i &lt; 0 || i &gt; L-&gt;length || L-&gt;length == 0) return ERROR;//异常处理 *e = L-&gt;data[i];//获取数据 for(int k = i; k &lt; L-&gt;length -1; k++) L-&gt;data[k] = L-&gt;data[k+1];//往前挪 L-&gt;length--; //长度减1 return OK;&#125;void PrintList(SqlList *L)&#123; if(L-&gt;length == 0) &#123; printf(\"顺序表为空\\n\"); &#125; printf(\"============遍历顺序表如下=============\\n\"); for(int i = 0; i &lt; L-&gt;length; i++) &#123; printf(\"\\tdata[%d] = %d\\n\", i, L-&gt;data[i]); &#125; printf(\"============共计%d个元素=============\\n\", L-&gt;length);&#125; 纯手打哈。。简单测试了一下。如果存在问题，欢迎指正，谢谢大家。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"test","slug":"2123","date":"2018-02-15T16:51:23.000Z","updated":"2018-02-15T16:53:11.477Z","comments":true,"path":"2018/02/16/2123/","link":"","permalink":"http://yoursite.com/2018/02/16/2123/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](https://hexo.io/docs/deploy","categories":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}],"tags":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/tags/Python全栈/"}],"keywords":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}]},{"title":"test","slug":"324","date":"2018-02-15T16:51:23.000Z","updated":"2018-02-15T16:53:11.477Z","comments":true,"path":"2018/02/16/324/","link":"","permalink":"http://yoursite.com/2018/02/16/324/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](https://hexo.io/docs/deploy","categories":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}],"tags":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/tags/Python全栈/"}],"keywords":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}]},{"title":"test","slug":"test","date":"2018-02-15T16:51:23.000Z","updated":"2018-02-15T16:53:11.477Z","comments":true,"path":"2018/02/16/test/","link":"","permalink":"http://yoursite.com/2018/02/16/test/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](https://hexo.io/docs/deploy","categories":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}],"tags":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/tags/Python全栈/"}],"keywords":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-15T13:34:33.765Z","updated":"2018-02-15T13:34:33.765Z","comments":true,"path":"2018/02/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}