{"meta":{"title":"无限Coding","subtitle":null,"description":null,"author":"infinitor","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"遗传算法(Genetic Algorithm)解决TSP问题","date":"2018-05-11T14:42:30.952Z","updated":"2018-04-28T07:21:59.000Z","comments":true,"path":"2018/05/11/遗传算法(Genetic Algorithm)解决TSP问题/","link":"","permalink":"http://yoursite.com/2018/05/11/遗传算法(Genetic Algorithm)解决TSP问题/","excerpt":"","text":"00 目录 遗传算法定义 生物学术语 问题导入 大体实现 具体细节 代码实现 01 什么是遗传算法？1.1 遗传算法的科学定义遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。 其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。 遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。 1.2 遗传算法的执行过程(参照百度百科)遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体实际上是染色体(chromosome)带有特征的实体。 染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码。 初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。 这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。 1.3 遗传算法过程图解 02 相关生物学术语为了大家更好了解遗传算法，在此之前先简单介绍一下相关生物学术语，大家了解一下即可。 基因型(genotype)：性状染色体的内部表现； 表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现； 进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。 适应度(fitness)：度量某个物种对于生存环境的适应程度。 选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。 复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交； 变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。 编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。 解码(decoding)：基因型到表现型的映射。 个体（individual）：指染色体带有特征的实体； 种群（population）：个体的集合，该集合内个体数称为种群 03 问题引出与解决3.1 一元函数最大值问题 如下的函数图像： 现在我们要在既定的区间内找出函数的最大值。 学过高中数学的孩纸都知道，上面的函数存在着很多的极大值和极小值。而最大值则是指定区间的极大值中的最大的那一个。从图像上具体表现为，极大值像是一座座山峰，极小值则是像一座座山谷。因此，我们也可以把遗传算法的过程看作是一个在多元函数里面求最优解的过程。 这些山峰对应着局部最优解，其中有一个山峰是海拔最高的，这个山峰则对应的是全局最优解。那么，遗传算法要做的就是尽量爬到最高峰，而不是困在较低的小山峰上。（如果问题求解是最小值，那么要做的就是尽量走到最低谷，道理是一样的）。 3.2 “袋鼠蹦跳”既然我们把函数曲线理解成一个一个山峰和山谷组成的山脉。那么我们可以设想所得到的每一个解就是一只袋鼠，我们希望它们不断的向着更高处跳去，直到跳到最高的山峰。所以求最大值的过程就转化成一个“袋鼠跳”的过程。 下面介绍介绍“袋鼠跳”的几种方式。 爬山算法：一只袋鼠朝着比现在高的地方跳去。它找到了不远处的最高的山峰。但是这座山不一定是最高峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。 模拟退火：袋鼠喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高峰跳去。这就是模拟退火算法。 遗传算法：有很多袋鼠，它们降落到喜玛拉雅山脉的任意地方。这些袋鼠并不知道它们的任务是寻找珠穆朗玛峰。但每过几年，就在一些海拔高度较低的地方射杀一些袋鼠。于是，不断有袋鼠死于海拔较低的地方，而越是在海拔高的袋鼠越是能活得更久，也越有机会生儿育女。就这样经过许多年，这些袋鼠们竟然都不自觉地聚拢到了一个个的山峰上，可是在所有的袋鼠中，只有聚拢到珠穆朗玛峰的袋鼠被带回了美丽的澳洲。 04 大体实现过程遗传算法中每一条染色体，对应着遗传算法的一个解决方案，一般我们用适应性函数（fitness function）来衡量这个解决方案的优劣。所以从一个基因组到其解的适应度形成一个映射。遗传算法的实现过程实际上就像自然界的进化过程那样。 下面我们用袋鼠跳中的步骤一一对应解释，以方便大家理解： 1) 首先寻找一种对问题潜在解进行“数字化”编码的方案。（建立表现型和基因型的映射关系） 2) 随机初始化一个种群（那么第一批袋鼠就被随意地分散在山脉上），种群里面的个体就是这些数字化的编码。 3) 接下来，通过适当的解码过程之后（得到袋鼠的位置坐标）。 4) 用适应性函数对每一个基因个体作一次适应度评估（袋鼠爬得越高当然就越好，所以适应度相应越高）。 5) 用选择函数按照某种规定择优选择（每隔一段时间，射杀一些所在海拔较低的袋鼠，以保证袋鼠总体数目持平。）。 6) 让个体基因变异（让袋鼠随机地跳一跳）。 7) 然后产生子代（希望存活下来的袋鼠是多产的，并在那里生儿育女）。 遗传算法并不保证你能获得问题的最优解，但是使用遗传算法的最大优点在于你不必去了解和操心如何去“找”最优解。（你不必去指导袋鼠向那边跳，跳多远。）而只要简单的“否定”一些表现不好的个体就行了。（把那些总是爱走下坡路的袋鼠射杀，这就是遗传算法的精粹！） 由此我们可以得出遗传算法的一般步骤： 1) 随机产生种群。2) 根据策略判断个体的适应度，是否符合优化准则，若符合，输出最佳个体及其最优解，结束。否则，进行下一步。3) 依据适应度选择父母，适应度高的个体被选中的概率高，适应度低的个体被淘汰。4) 用父母的染色体按照一定的方法进行交叉，生成子代。5) 对子代染色体进行变异。 由交叉和变异产生新一代种群，返回步骤2，直到最优解产生。 具体图解可以回到1.3查看。 05 开始我们的进化(具体实现细节)5.1 先从编码说起编码是应用遗传算法时要解决的首要问题，也是设计遗传算法时的一个关键步骤。编码方法影响到交叉算子、变异算子等遗传算子的运算方法，大很大程度上决定了遗传进化的效率。 迄今为止人们已经提出了许多种不同的编码方法。总的来说，这些编码方法可以分为三大类：二进制编码法、浮点编码法、符号编码法。下面分别进行介绍： 5.1.1 二进制编码法就像人类的基因有AGCT 4种碱基序列一样。不过在这里我们只用了0和1两种碱基,然后将他们串成一条链形成染色体。一个位能表示出2种状态的信息量，因此足够长的二进制染色体便能表示所有的特征。这便是二进制编码。如下：1110001010111 它由二进制符号0和1所组成的二值符号集。它有以下一些优点： 1) 编码、解码操作简单易行2) 交叉、变异等遗传操作便于实现3) 合最小字符集编码原则4) 利用模式定理对算法进行理论分析。 二进制编码的缺点是：对于一些连续函数的优化问题，由于其随机性使得其局部搜索能力较差，如对于一些高精度的问题（如上题），当解迫近于最优解后，由于其变异后表现型变化很大，不连续，所以会远离最优解，达不到稳定。 5.1.２ 浮点编码法二进制编码虽然简单直观，但明显地。但是存在着连续函数离散化时的映射误差。个体长度较短时，可能达不到精度要求，而个体编码长度较长时，虽然能提高精度，但增加了解码的难度，使遗传算法的搜索空间急剧扩大。 所谓浮点法，是指个体的每个基因值用某一范围内的一个浮点数来表示。在浮点数编码方法中，必须保证基因值在给定的区间限制范围内，遗传算法中所使用的交叉、变异等遗传算子也必须保证其运算结果所产生的新个体的基因值也在这个区间限制范围内。如下所示： 1.2-3.2-5.3-7.2-1.4-9.7 浮点数编码方法有下面几个优点： 1) 适用于在遗传算法中表示范围较大的数2) 适用于精度要求较高的遗传算法3) 便于较大空间的遗传搜索4) 改善了遗传算法的计算复杂性，提高了运算交率5) 便于遗传算法与经典优化方法的混合使用6) 便于设计针对问题的专门知识的知识型遗传算子7) 便于处理复杂的决策变量约束条件 5.1.3 符号编码法符号编码法是指个体染色体编码串中的基因值取自一个无数值含义、而只有代码含义的符号集如｛A,B,C…｝。符号编码的主要优点是： 1) 符合有意义积术块编码原则2) 便于在遗传算法中利用所求解问题的专门知识3) 便于遗传算法与相关近似算法之间的混合使用。 5.2 为我们的袋鼠染色体编码在上面介绍了一系列编码方式以后，那么，如何利用上面的编码来为我们的袋鼠染色体编码呢？首先我们要明确一点：编码无非就是建立从基因型到表现型的映射关系。这里的表现型可以理解为个体特征（比如身高、体重、毛色等等）。那么，在此问题下，我们关心的个体特征就是：袋鼠的位置坐标（因为我们要把海拔低的袋鼠给杀掉）。无论袋鼠长什么样，爱吃什么。我们关心的始终是袋鼠在哪里，并且只要知道了袋鼠的位置坐标（位置坐标就是相应的染色体编码，可以通过解码得出），我们就可以： 1) 在喜马拉雅山脉的地图上找到相应的位置坐标，算出海拔高度。（相当于通过自变量求得适应函数的值）然后判读该不该射杀该袋鼠。2) 可以知道染色体交叉和变异后袋鼠新的位置坐标。 回到3.1中提的求一元函数最大值的问题。在上面我们把极大值比喻为山峰，那么，袋鼠的位置坐标可以比喻为区间[-1, 2]的某一个x坐标（有了x坐标，再通过函数表达式可以算出函数值 &lt;==&gt; 得到了袋鼠染色体编码，解码得到位置坐标，在喜马拉雅山脉地图查询位置坐标算出海拔高度）。这个x坐标是一个实数，现在，说白了就是怎么对这个x坐标进行编码。下面我们以二进制编码为例讲解，不过这种情况下以二进制编码比较复杂就是了。（如果以浮点数编码，其实就很简洁了，就一浮点数而已。） 我们说过，一定长度的二进制编码序列，只能表示一定精度的浮点数。在这里假如我们要求解精确到六位小数，由于区间长度为2 - (-1) = 3 ,为了保证精度要求，至少把区间[-1,2]分为3 × 10^6等份。又因为 2^21 = 2097152 &lt; 3*10^6 &lt; 2^22 = 4194304 所以编码的二进制串至少需要22位。 把一个二进制串(b0,b1,….bn)转化为区间里面对应的实数值可以通过下面两个步骤： 1) 将一个二进制串代表的二进制数转化为10进制数： ![](http://oyxhmjutw.bkt.clouddn.com/18-4-28/19594055.jpg) 2) 对应区间内的实数： ![](http://oyxhmjutw.bkt.clouddn.com/18-4-28/77256389.jpg) 例如一个二进制串(1000101110110101000111)2通过上面换算以后，表示实数值0.637197。 好了，上面的编码方式只是举个例子让大家更好理解而已，编码的方式千奇百怪，层出不穷，每个问题可能采用的编码方式都不一样。在这一点上大家要注意。 5.3 评价个体的适应度–适应度函数（fitness function）前面说了，适应度函数主要是通过个体特征从而判断个体的适应度。在本例的袋鼠跳中，我们只关心袋鼠的海拔高度，以此来判断是否该射杀该袋鼠。这样一来，该函数就非常简单了。只要输入袋鼠的位置坐标，在通过相应查找运算，返回袋鼠当前位置的海拔高度就行。 适应度函数也称评价函数，是根据目标函数确定的用于区分群体中个体好坏的标准。适应度函数总是非负的，而目标函数可能有正有负，故需要在目标函数与适应度函数之间进行变换。 评价个体适应度的一般过程为： 对个体编码串进行解码处理后，可得到个体的表现型。 由个体的表现型可计算出对应个体的目标函数值。 根据最优化问题的类型，由目标函数值按一定的转换规则求出个体的适应度。 5.4 射杀一些袋鼠–选择函数（selection）遗传算法中的选择操作就是用来确定如何从父代群体中按某种方法选取那些个体，以便遗传到下一代群体。选择操作用来确定重组或交叉个体，以及被选个体将产生多少个子代个体。前面说了，我们希望海拔高的袋鼠存活下来，并尽可能繁衍更多的后代。但我们都知道，在自然界中，适应度高的袋鼠越能繁衍后代，但这也是从概率上说的而已。毕竟有些适应度低的袋鼠也可能逃过我们的眼睛。 那么，怎么建立这种概率关系呢？ 下面介绍几种常用的选择算子： 轮盘赌选择（Roulette Wheel Selection）：是一种回放式随机采样方法。每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例。选择误差较大。 随机竞争选择（Stochastic Tournament）：每次按轮盘赌选择一对个体，然后让这两个个体进行竞争，适应度高的被选中，如此反复，直到选满为止。 最佳保留选择：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地复制到下一代群体中。 无回放随机选择（也叫期望值选择Excepted Value Selection）：根据每个个体在下一代群体中的生存期望来进行随机选择运算。方法如下: （1） 计算群体中每个个体在下一代群体中的生存期望数目N。 （2） 若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去0.5，若某一个体未 被选中参与交叉运算，则它在下一代中的生存期望数目减去1.0。 （3） 随着选择过程的进行，若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。 确定式选择：按照一种确定的方式来进行选择操作。具体操作过程如下： （1） 计算群体中各个个体在下一代群体中的期望生存数目N。 （2） 用N的整数部分确定各个对应个体在下一代群体中的生存数目。 （3） 用N的小数部分对个体进行降序排列，顺序取前M个个体加入到下一代群体中。至此可完全确定出下一代群体中Ｍ个个体。 无回放余数随机选择：可确保适应度比平均适应度大的一些个体能够被遗传到下一代群体中，因而选择误差比较小。 均匀排序：对群体中的所有个体按期适应度大小进行排序，基于这个排序来分配各个个体被选中的概率。 最佳保存策略：当前群体中适应度最高的个体不参与交叉运算和变异运算，而是用它来代替掉本代群体中经过交叉、变异等操作后所产生的适应度最低的个体。 随机联赛选择：每次选取几个个体中适应度最高的一个个体遗传到下一代群体中。 排挤选择：新生成的子代将代替或排挤相似的旧父代个体，提高群体的多样性。 下面以轮盘赌选择为例给大家讲解一下： 假如有５条染色体，他们的适应度分别为５、８、３、７、２。 那么总的适应度为：F = 5 + 8 + 3 + 7 + 2 = 25。 那么各个个体的被选中的概率为： α1 = ( 5 / 25 ) * 100% = 20% α2 = ( 8 / 25 ) * 100% = 32% α3 = ( 3 / 25 ) * 100% = 12% α4 = ( 7 / 25 ) * 100% = 28% α5 = ( 2 / 25 ) * 100% = 8% 所以转盘如下： 当指针在这个转盘上转动，停止下来时指向的个体就是天选之人啦。可以看出，适应性越高的个体被选中的概率就越大。 5.５ 遗传–染色体交叉(crossover)遗传算法的交叉操作，是指对两个相互配对的染色体按某种方式相互交换其部分基因，从而形成两个新的个体。 适用于二进制编码个体或浮点数编码个体的交叉算子： 单点交叉（One-point Crossover）：指在个体编码串中只随机设置一个交叉点，然后再该点相互交换两个配对个体的部分染色体。 两点交叉与多点交叉： (1) 两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换。 (2) 多点交叉（Multi-point Crossover） 均匀交叉（也称一致交叉，Uniform Crossover）：两个配对个体的每个基因座上的基因都以相同的交叉概率进行交换，从而形成两个新个体。 算术交叉（Arithmetic Crossover）：由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。 咳咳，根据国际惯例。还是抓一个最简单的二进制单点交叉为例来给大家讲解讲解。 二进制编码的染色体交叉过程非常类似高中生物中所讲的同源染色体的联会过程――随机把其中几个位于同一位置的编码进行交换，产生新的个体。 对应的二进制交叉： 5.6 变异–基因突变(Mutation)遗传算法中的变异运算，是指将个体染色体编码串中的某些基因座上的基因值用该基因座上的其它等位基因来替换，从而形成新的个体。 例如下面这串二进制编码： 101101001011001 经过基因突变后，可能变成以下这串新的编码： 001101011011001 以下变异算子适用于二进制编码和浮点数编码的个体： 基本位变异（Simple Mutation）：对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。 均匀变异（Uniform Mutation）：分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。（特别适用于在算法的初级运行阶段） 边界变异（Boundary Mutation）：随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。 非均匀变异：对原有的基因值做一随机扰动，以扰动后的结果作为变异后的新基因值。对每个基因座都以相同的概率进行变异运算之后，相当于整个解向量在解空间中作了一次轻微的变动。 高斯近似变异：进行变异操作时用符号均值为Ｐ的平均值，方差为P**2的正态分布的一个随机数来替换原有的基因值。 06 代码实现环节好了，上面我们介绍了一大截具体原理。现在就是把各个具体的零部件组装起来，动手写我们的代码了。","categories":[],"tags":[],"keywords":[]},{"title":"经典语录","slug":"来自酷壳一些话的感想","date":"2018-02-21T02:53:32.000Z","updated":"2018-05-05T15:03:35.922Z","comments":true,"path":"2018/02/21/来自酷壳一些话的感想/","link":"","permalink":"http://yoursite.com/2018/02/21/来自酷壳一些话的感想/","excerpt":"前两天翻了翻酷壳的网站，发现上面的文章写得确实是不错。感觉对自己的启发也很大。所以在这里Mark一下。 摘自于：https://coolshell.cn/","text":"前两天翻了翻酷壳的网站，发现上面的文章写得确实是不错。感觉对自己的启发也很大。所以在这里Mark一下。 摘自于：https://coolshell.cn/ 兴趣和热情只能让你很执着，但并不一定能让你走好这条路，只有你的能力和你的强项才能让你走好这条路。希望大家能够清楚地认识到这其中的差别。 既然要活在体制外，就一定是靠能力，靠经历，一定要有好的经历和能力。 我从不畏惧在北京是否有户口，那里的房价是否承受的起，我觉得一个刚毕业的学生没必要太多的考虑这些问题，最重要的是考虑自己的发展。 我在此想告诉大家，对于你的人生你应该把“和什么样的人做什么样的事”提到你择业优先级最高的地位，没有之一。我的答案是，“和有激情能做事的人做有意义的事”。 生活在如此刺激的年代，一定要去经历那些最刺激最有意义的东西，这样人生才会变得有意义。 如果你不喜欢，你就要说出来，不要将就，将就出来的人生只会平添许多烦恼和后悔。 软件的精髓不在于你对系统底层有多了解，也不在语言层面，而是在于设计和架构，而设计和架构这种东西只能靠多想多看。 最有价值的东西就是——能和那些有梦想有追求有能力的人一起去经历那些最有意义的事情，那些能够造福社会、改变世界、创造历史的事情。","categories":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/tags/随想/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}]},{"title":"10分钟教你用python打造贪吃蛇超详细教程","slug":"Python实现贪吃蛇(超详细)","date":"2018-02-19T04:23:21.000Z","updated":"2018-05-05T15:11:11.574Z","comments":true,"path":"2018/02/19/Python实现贪吃蛇(超详细)/","link":"","permalink":"http://yoursite.com/2018/02/19/Python实现贪吃蛇(超详细)/","excerpt":"10分钟教你用python打造贪吃蛇超详细教程在家闲着没妹子约, 刚好最近又学了一下python，听说pygame挺好玩的。今天就在家研究一下， 弄了个贪吃蛇出来。希望大家喜欢。","text":"10分钟教你用python打造贪吃蛇超详细教程在家闲着没妹子约, 刚好最近又学了一下python，听说pygame挺好玩的。今天就在家研究一下， 弄了个贪吃蛇出来。希望大家喜欢。 先看程序效果： 01 整体框架平台：pycharm 关于pygame的安装这里就不在赘述，大家自行上网找合适自己的版本的安装即可。关于pygame模块知识会穿插在下面代码中介绍，用到什么就介绍什么。这里就不统一介绍了。 整个程序由于是调用了大量的pygame里面的库函数，所以也非常简单（卧槽你这不是调包侠嘛）。也就200多行代码。基于整体怎么设计的呢？看下面的图： 由于程序没有多么复杂，就直接用面向过程的思路写了。毕竟这么小的程序没必要整一大堆class来为难自己对吧。 程序整体代码框架： pycharm里面一堆波浪线也是很无奈。 02 main主函数-开始工作此函数也非常简单。主要承担一些游戏窗口的初始化工作，以及调用相关函数运行游戏。代码如下： 123456789101112#主函数def main(): pygame.init() # 模块初始化 snake_speed_clock = pygame.time.Clock() # 创建Pygame时钟对象 screen = pygame.display.set_mode((windows_width, windows_height)) # screen.fill(white) pygame.display.set_caption(\"Python 贪吃蛇小游戏\") #设置标题 show_start_info(screen) #欢迎信息 while True: running_game(screen, snake_speed_clock) show_gameover_info(screen) 基于以上代码，咱们来做几点讲解： pygame.time.Clock() 控制帧速率。pygame.time.Clock()会控制每个循环多长时间运行一次。这就好比，有个定时器在控制着时间进程，一到时间就告诉CPU： 现在该开始循环了！ 现在该开始循环了！ 使用pygame时钟之前，必须先创建Clock对象的一个实例，这与创建其他类的实例完全相同。Clock= Pygame.time.Clock()。然后在主循环体中，只需要告诉时钟多久“提醒”一次——-也就是说，循环应该多长时间运行一次：clock.tick(60)。 传入clock.tick()的数不是一个毫秒数。这是每秒内循环要运行的次数，所以这个循环应当每秒运行60次，在这里我只是说应当运行，因为循环只能按计算机能够保证的速度运行，每秒60个循环（或帧）时，每个循环需要1000/60=16.66ms（大约17ms）如果循环中的代码运行时间超过17ms，在clock指出下一次循环时当前循环将无法完成。 再说通俗一点，就是我们游戏的fps嘛。每秒多少帧这样。至于后面在哪clock.tick()，下面会讲。 详细可参考这篇文章：http://eyehere.net/2011/python-pygame-novice-professional-8/ pygame.display.set_mode((windows_width, windows_height)) 生成windows窗口，pygame.display.set_mode(resolution=(0,0),flags=0,depth=0)。返回的是一个surface对象(surface对象是用于表示图像的图像，只要指定尺寸，就可以利用)，resolution可以控制生成windows窗口的大小，flags代表的是扩展选项，depath不推荐设置。 flags标志位控制你想要什么样的显示屏，主要有下面几个，这几个量相当于是全局的常量，使用的时候可以from pygame.locals import *导入： pygame.FULLSCREEN，控制全屏,0或者1来控制 pygame.HWSURFACE 控制是否进行硬件加速 pygame.RESIZABLE 控制窗口是否可以调节大小 screen.fill(white）pygame.surface.fill(color)。对surface对象填充某一种颜色，在这里表现为窗口背景颜色的填充。 以上讲完，然后就是运行我们游戏三个函数了。 show_start_info(screen)显示欢迎信息，最终效果表现为： 当然，怎么实现，待会说。 接着死循环。因为我们的游戏设置是，当GameOver以后，我们可以按任意键重新开始游戏，或者退出。因此最后不断循环判断用户是否想重新开始游戏，就这样而已。 游戏主体running_game(screen, snake_speed_clock)贪吃蛇运行的主体函数。整个程序的精髓所在。 show_gameover_info(screen)贪吃蛇死了，显示GameOver，表现为： 怎么实现，下面说。 03 show_start_info()欢迎进入游戏先贴代码，待会讲解。12345678910111213141516171819#开始信息显示def show_start_info(screen): font = pygame.font.Font('myfont.ttf', 40) tip = font.render('按任意键开始游戏~~~', True, (65, 105, 225)) gamestart = pygame.image.load('gamestart.png') screen.blit(gamestart, (140, 30)) screen.blit(tip, (240, 550)) pygame.display.update() while True: #键盘监听事件 for event in pygame.event.get(): # event handling loop if event.type == QUIT: terminate() #终止程序 elif event.type == KEYDOWN: if (event.key == K_ESCAPE): #终止程序 terminate() #终止程序 else: return #结束此函数, 开始游戏 字体显示 先创建一个Font对象，用自己的字体。有了Font对象以后， 就可以用render方法来写字了，然后通过blit方法blit到屏幕上。 图像加载 用 pygame.image.load()加载图像获得对象，在用blit方法刷到屏幕上。做完以上事件以后，记得要update一下刷新一下屏幕。 监听键盘 按任意键继续或者ESC退出…… 04 running_game-让我们开始游戏吧running_game(screen, snake_speed_clock)是游戏主要功能，在这里给大家慢慢讲解。先贴代码：123456789101112131415161718192021222324252627282930313233343536373839404142#游戏运行主体def running_game(screen,snake_speed_clock): startx = random.randint(3, map_width - 8) #开始位置 starty = random.randint(3, map_height - 8) snake_coords = [&#123;'x': startx, 'y': starty&#125;, #初始贪吃蛇 &#123;'x': startx - 1, 'y': starty&#125;, &#123;'x': startx - 2, 'y': starty&#125;] direction = RIGHT # 开始时向右移动 food = get_random_location() #实物随机位置 while True: for event in pygame.event.get(): if event.type == QUIT: terminate() elif event.type == KEYDOWN: if (event.key == K_LEFT or event.key == K_a) and direction != RIGHT: direction = LEFT elif (event.key == K_RIGHT or event.key == K_d) and direction != LEFT: direction = RIGHT elif (event.key == K_UP or event.key == K_w) and direction != DOWN: direction = UP elif (event.key == K_DOWN or event.key == K_s) and direction != UP: direction = DOWN elif event.key == K_ESCAPE: terminate() move_snake(direction, snake_coords) #移动蛇 ret = snake_is_alive(snake_coords) if not ret: break #蛇跪了. 游戏结束 snake_is_eat_food(snake_coords, food) #判断蛇是否吃到食物 screen.fill(BG_COLOR) #draw_grid(screen) draw_snake(screen, snake_coords) draw_food(screen, food) draw_score(screen, len(snake_coords) - 3) pygame.display.update() snake_speed_clock.tick(snake_speed) #控制fps 关于贪吃蛇 这里我们采用一个元组存储贪吃蛇身体各个部分的坐标(一条贪吃蛇不是由很多节组成的嘛)。最后再写个方法根据元组坐标把贪吃蛇画出来就行。 关于食物 同样做法。存坐标，最后画出来。 关于移动 监听键盘，根据用户按键，用direction变量记录移动方向。然后更新贪吃蛇元组里面的坐标(其实每次移动只用更新头尾就行)。最后统一画出来。移动做法具体是，我们把每次头部移动的新坐标插入贪吃蛇元组，然后删掉尾部一节(注意，删除尾部我们放在了另外一个函数里做)。 123456789101112#移动贪吃蛇def move_snake(direction, snake_coords): if direction == UP: newHead = &#123;'x': snake_coords[HEAD]['x'], 'y': snake_coords[HEAD]['y'] - 1&#125; elif direction == DOWN: newHead = &#123;'x': snake_coords[HEAD]['x'], 'y': snake_coords[HEAD]['y'] + 1&#125; elif direction == LEFT: newHead = &#123;'x': snake_coords[HEAD]['x'] - 1, 'y': snake_coords[HEAD]['y']&#125; elif direction == RIGHT: newHead = &#123;'x': snake_coords[HEAD]['x'] + 1, 'y': snake_coords[HEAD]['y']&#125; snake_coords.insert(0, newHead) 开始阶段 先把贪吃蛇和食物的坐标随机生成，贪吃蛇一开始3节长，先设置向右移动。 移动我们的贪吃蛇 监听键盘，用户按下键盘只是改变direction的值，再用move_snake(direction, snake_coords)函数更新贪吃蛇坐标。如果不按，那direction值一直不变，贪吃蛇就一直向前走。 相关判断 要判断贪吃蛇是否挂了，表现为： 头坐标超出地图范围 头坐标等于身体某节坐标 12345678910 #判断蛇死了没def snake_is_alive(snake_coords): tag = True if snake_coords[HEAD]['x'] == -1 or snake_coords[HEAD]['x'] == map_width or snake_coords[HEAD]['y'] == -1 or \\ snake_coords[HEAD]['y'] == map_height: tag = False # 蛇碰壁啦 for snake_body in snake_coords[1:]: if snake_body['x'] == snake_coords[HEAD]['x'] and snake_body['y'] == snake_coords[HEAD]['y']: tag = False # 蛇碰到自己身体啦 return tag 判断贪吃蛇是否吃到食物，表现为： 头坐标等于食物坐标，那么吃到食物。这时候注意，我们就不用删尾部一节了，因为吃到食物变长了嘛。 如果没有吃到食物，那么是正常移动，删掉尾部一节坐标。1234567 #判断贪吃蛇是否吃到食物def snake_is_eat_food(snake_coords, food): #如果是列表或字典，那么函数内修改参数内容，就会影响到函数体外的对象。 if snake_coords[HEAD]['x'] == food['x'] and snake_coords[HEAD]['y'] == food['y']: food['x'] = random.randint(0, map_width - 1) food['y'] = random.randint(0, map_height - 1) # 实物位置重新设置 else: del snake_coords[-1] # 如果没有吃到实物, 就向前移动, 那么尾部一格删掉 画出我们的游戏最后调用相关函数，讲我们的地图，贪吃蛇，食物等等统统画出来。 05 draw_snake-画出我们的贪吃蛇直接看代码：123456789def draw_snake(screen, snake_coords): for coord in snake_coords: x = coord['x'] * cell_size y = coord['y'] * cell_size wormSegmentRect = pygame.Rect(x, y, cell_size, cell_size) pygame.draw.rect(screen, dark_blue, wormSegmentRect) wormInnerSegmentRect = pygame.Rect( #蛇身子里面的第二层亮蓝色色 x + 4, y + 4, cell_size - 8, cell_size - 8) pygame.draw.rect(screen, blue, wormInnerSegmentRect) 代码很easy，主要是获取相关坐标，最后调用pygame.draw.rect将身体各个部分画出来即可。不过为了美观，我们选择再在里面画一层不同颜色的，表现为： 06 draw_food-画出我们的食物123456#将食物画出来def draw_food(screen, food): x = food['x'] * cell_size y = food['y'] * cell_size appleRect = pygame.Rect(x, y, cell_size, cell_size) pygame.draw.rect(screen, Red, appleRect) 更简单的代码了，获取位置，画矩形。 07 draw_score-画出我们的成绩1234567#画成绩def draw_score(screen,score): font = pygame.font.Font('myfont.ttf', 30) scoreSurf = font.render('得分: %s' % score, True, Green) scoreRect = scoreSurf.get_rect() scoreRect.topleft = (windows_width - 120, 10) screen.blit(scoreSurf, scoreRect) 画成绩也比较简单。获得Font对象以后，render写字，最后设置位置，在屏幕上blit出来。 08 完整代码整个程序大体如上，其他细枝末节直接看源代码吧。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202## 导入相关模块import randomimport pygameimport sysfrom pygame.locals import *snake_speed = 15 #贪吃蛇的速度windows_width = 800windows_height = 600 #游戏窗口的大小cell_size = 20 #贪吃蛇身体方块大小,注意身体大小必须能被窗口长宽整除''' #初始化区由于我们的贪吃蛇是有大小尺寸的, 因此地图的实际尺寸是相对于贪吃蛇的大小尺寸而言的'''map_width = int(windows_width / cell_size)map_height = int(windows_height / cell_size)# 颜色定义white = (255, 255, 255)black = (0, 0, 0)gray = (230, 230, 230)dark_gray = (40, 40, 40)DARKGreen = (0, 155, 0)Green = (0, 255, 0)Red = (255, 0, 0)blue = (0, 0, 255)dark_blue =(0,0, 139)BG_COLOR = black #游戏背景颜色# 定义方向UP = 1DOWN = 2LEFT = 3RIGHT = 4HEAD = 0 #贪吃蛇头部下标#主函数def main(): pygame.init() # 模块初始化 snake_speed_clock = pygame.time.Clock() # 创建Pygame时钟对象 screen = pygame.display.set_mode((windows_width, windows_height)) # screen.fill(white) pygame.display.set_caption(\"Python 贪吃蛇小游戏\") #设置标题 show_start_info(screen) #欢迎信息 while True: running_game(screen, snake_speed_clock) show_gameover_info(screen)#游戏运行主体def running_game(screen,snake_speed_clock): startx = random.randint(3, map_width - 8) #开始位置 starty = random.randint(3, map_height - 8) snake_coords = [&#123;'x': startx, 'y': starty&#125;, #初始贪吃蛇 &#123;'x': startx - 1, 'y': starty&#125;, &#123;'x': startx - 2, 'y': starty&#125;] direction = RIGHT # 开始时向右移动 food = get_random_location() #实物随机位置 while True: for event in pygame.event.get(): if event.type == QUIT: terminate() elif event.type == KEYDOWN: if (event.key == K_LEFT or event.key == K_a) and direction != RIGHT: direction = LEFT elif (event.key == K_RIGHT or event.key == K_d) and direction != LEFT: direction = RIGHT elif (event.key == K_UP or event.key == K_w) and direction != DOWN: direction = UP elif (event.key == K_DOWN or event.key == K_s) and direction != UP: direction = DOWN elif event.key == K_ESCAPE: terminate() move_snake(direction, snake_coords) #移动蛇 ret = snake_is_alive(snake_coords) if not ret: break #蛇跪了. 游戏结束 snake_is_eat_food(snake_coords, food) #判断蛇是否吃到食物 screen.fill(BG_COLOR) #draw_grid(screen) draw_snake(screen, snake_coords) draw_food(screen, food) draw_score(screen, len(snake_coords) - 3) pygame.display.update() snake_speed_clock.tick(snake_speed) #控制fps#将食物画出来def draw_food(screen, food): x = food['x'] * cell_size y = food['y'] * cell_size appleRect = pygame.Rect(x, y, cell_size, cell_size) pygame.draw.rect(screen, Red, appleRect)#将贪吃蛇画出来def draw_snake(screen, snake_coords): for coord in snake_coords: x = coord['x'] * cell_size y = coord['y'] * cell_size wormSegmentRect = pygame.Rect(x, y, cell_size, cell_size) pygame.draw.rect(screen, dark_blue, wormSegmentRect) wormInnerSegmentRect = pygame.Rect( #蛇身子里面的第二层亮绿色 x + 4, y + 4, cell_size - 8, cell_size - 8) pygame.draw.rect(screen, blue, wormInnerSegmentRect)#画网格(可选)def draw_grid(screen): for x in range(0, windows_width, cell_size): # draw 水平 lines pygame.draw.line(screen, dark_gray, (x, 0), (x, windows_height)) for y in range(0, windows_height, cell_size): # draw 垂直 lines pygame.draw.line(screen, dark_gray, (0, y), (windows_width, y))#移动贪吃蛇def move_snake(direction, snake_coords): if direction == UP: newHead = &#123;'x': snake_coords[HEAD]['x'], 'y': snake_coords[HEAD]['y'] - 1&#125; elif direction == DOWN: newHead = &#123;'x': snake_coords[HEAD]['x'], 'y': snake_coords[HEAD]['y'] + 1&#125; elif direction == LEFT: newHead = &#123;'x': snake_coords[HEAD]['x'] - 1, 'y': snake_coords[HEAD]['y']&#125; elif direction == RIGHT: newHead = &#123;'x': snake_coords[HEAD]['x'] + 1, 'y': snake_coords[HEAD]['y']&#125; snake_coords.insert(0, newHead)#判断蛇死了没def snake_is_alive(snake_coords): tag = True if snake_coords[HEAD]['x'] == -1 or snake_coords[HEAD]['x'] == map_width or snake_coords[HEAD]['y'] == -1 or \\ snake_coords[HEAD]['y'] == map_height: tag = False # 蛇碰壁啦 for snake_body in snake_coords[1:]: if snake_body['x'] == snake_coords[HEAD]['x'] and snake_body['y'] == snake_coords[HEAD]['y']: tag = False # 蛇碰到自己身体啦 return tag#判断贪吃蛇是否吃到食物def snake_is_eat_food(snake_coords, food): #如果是列表或字典，那么函数内修改参数内容，就会影响到函数体外的对象。 if snake_coords[HEAD]['x'] == food['x'] and snake_coords[HEAD]['y'] == food['y']: food['x'] = random.randint(0, map_width - 1) food['y'] = random.randint(0, map_height - 1) # 实物位置重新设置 else: del snake_coords[-1] # 如果没有吃到实物, 就向前移动, 那么尾部一格删掉#食物随机生成def get_random_location(): return &#123;'x': random.randint(0, map_width - 1), 'y': random.randint(0, map_height - 1)&#125;#开始信息显示def show_start_info(screen): font = pygame.font.Font('myfont.ttf', 40) tip = font.render('按任意键开始游戏~~~', True, (65, 105, 225)) gamestart = pygame.image.load('gamestart.png') screen.blit(gamestart, (140, 30)) screen.blit(tip, (240, 550)) pygame.display.update() while True: #键盘监听事件 for event in pygame.event.get(): # event handling loop if event.type == QUIT: terminate() #终止程序 elif event.type == KEYDOWN: if (event.key == K_ESCAPE): #终止程序 terminate() #终止程序 else: return #结束此函数, 开始游戏#游戏结束信息显示def show_gameover_info(screen): font = pygame.font.Font('myfont.ttf', 40) tip = font.render('按Q或者ESC退出游戏, 按任意键重新开始游戏~', True, (65, 105, 225)) gamestart = pygame.image.load('gameover.png') screen.blit(gamestart, (60, 0)) screen.blit(tip, (80, 300)) pygame.display.update() while True: #键盘监听事件 for event in pygame.event.get(): # event handling loop if event.type == QUIT: terminate() #终止程序 elif event.type == KEYDOWN: if event.key == K_ESCAPE or event.key == K_q: #终止程序 terminate() #终止程序 else: return #结束此函数, 重新开始游戏#画成绩def draw_score(screen,score): font = pygame.font.Font('myfont.ttf', 30) scoreSurf = font.render('得分: %s' % score, True, Green) scoreRect = scoreSurf.get_rect() scoreRect.topleft = (windows_width - 120, 10) screen.blit(scoreSurf, scoreRect)#程序终止def terminate(): pygame.quit() sys.exit()main() 程序及资源下载：https://pan.baidu.com/s/1jJ0rawm","categories":[{"name":"全栈","slug":"全栈","permalink":"http://yoursite.com/categories/全栈/"}],"tags":[{"name":"Python, 游戏","slug":"Python-游戏","permalink":"http://yoursite.com/tags/Python-游戏/"}],"keywords":[{"name":"全栈","slug":"全栈","permalink":"http://yoursite.com/categories/全栈/"}]},{"title":"用模拟退火(SA, Simulated Annealing)算法解决旅行商问题 (TSP, Traveling Salesman Problem)","slug":"用模拟退火-SA-Simulated-Annealing-算法解决旅行商问题-TSP-Traveling-Salesman-Problem","date":"2018-02-18T05:46:37.000Z","updated":"2018-05-05T15:10:34.770Z","comments":true,"path":"2018/02/18/用模拟退火-SA-Simulated-Annealing-算法解决旅行商问题-TSP-Traveling-Salesman-Problem/","link":"","permalink":"http://yoursite.com/2018/02/18/用模拟退火-SA-Simulated-Annealing-算法解决旅行商问题-TSP-Traveling-Salesman-Problem/","excerpt":"01 什么是旅行商问题(TSP)? TSP问题（Traveling Salesman Problem，旅行商问题），由威廉哈密顿爵士和英国数学家克克曼T.P.Kirkman于19世纪初提出。问题描述如下：有若干个城市，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路已保证其旅行的费用最少？","text":"01 什么是旅行商问题(TSP)? TSP问题（Traveling Salesman Problem，旅行商问题），由威廉哈密顿爵士和英国数学家克克曼T.P.Kirkman于19世纪初提出。问题描述如下：有若干个城市，任何两个城市之间的距离都是确定的，现要求一旅行商从某城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的城市，问如何事先确定一条最短的线路已保证其旅行的费用最少？ 如下图所示： 02 模拟退火算法（Simulate Annealing Arithmetic，SAA）2.1 什么是模拟退火算法(简介)?模拟退火算法（Simulate Annealing Arithmetic，SAA）是一种通用概率演算法，用来在一个大的搜寻空间内找寻命题的最优解。它是基于Monte-Carlo迭代求解策略的一种随机寻优算法。 模拟退火算法是S.Kirkpatrick, C.D.Gelatt和M.P.Vecchi等人在1983年发明的，1985年，V.Černý也独立发明了此演算法。模拟退火算法是解决TSP问题的有效方法之一。 2.2 模拟退火算法的来源模拟退火算法来源于固体退火原理。 物理退火: 将材料加热后再经特定速率冷却，目的是增大晶粒的体积，并且减少晶格中的缺陷。材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来位置，而随机在其他位置中移动。退火冷却时速度较慢，使得原子有较多可能可以找到内能比原先更低的位置。 模拟退火: 其原理也和固体退火的原理近似。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。 2.3 模拟退火算法思想在介绍模拟退火算法之前，有必要给大家科普一下爬山算法 (Hill Climbing)。 2.3.1 爬山算法爬山算法是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。这种算法思想很单纯，但是也存在一个很大的缺陷。在搜索选择的过程中有可能会陷入局部最优解，而这个局部最优解不一定是全局最优解。比如下面这个问题： 假设A是当前解，爬山算法往前继续搜索，当搜索到B这个局部最优解时就会停止搜索了。因为此时在B点无论是往哪边走都不会得到更优的解了。但是，聪明的同学已经发现了，全局最优解在C点。 2.3.2 模拟退火算法爬山法是完完全全的贪心法，这种贪心是很鼠目寸光的，只把眼光放在局部最优解上，因此只能搜索到局部的最优值。模拟退火其实也是一种贪心算法，只不过与爬山法不同的是，模拟退火算法在搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。从上图来说，模拟退火算法在搜索到局部最优解B后，会以一定的概率接受向右的移动。也许经过几次这样的不是局部最优的移动后会到达BC之间的峰点D，这样一来便跳出了局部最优解B，继续往右移动就有可能获得全局最优解C。如下图： 关于普通Greedy算法与模拟退火，这里也有一个有趣的比喻： 普通Greedy算法：兔子朝着比现在低的地方跳去。它找到了不远处的最低的山谷。但是这座山谷不一定最低的。 模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向低处，也可能踏入平地。但是，它渐渐清醒了并朝最低的方向跳去。 如此一来，大家对模拟退火算法有了一定的认识，但是这还是不够的。对比上面两种算法，对于模拟退火算法我们提到了一个很important的概念–一定的概率，关于这个一定的概率是如何计算的。这里还是参考了固体的物理退火过程。 根据热力学的原理，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为： P(dE) = exp( dE/(kT) ) 其中k是一个常数，exp表示自然指数，且dE&lt;0(温度总是降低的)。这条公式指明了：1) 温度越高，出现一次能量差为dE的降温的概率就越大；2) 温度越低，则出现降温的概率就越小。又由于dE总是小于0（不然怎么叫退火），因此dE/kT &lt; 0 ，exp(dE/kT)取值是(0,1),那么P(dE)的函数取值范围是(0,1) 。 随着温度T的降低，P(dE)会逐渐降低。我们将一次向较差解的移动看做一次温度跳变过程，我们以概率P(dE)来接受这样的移动。也就是说，在用固体退火模拟组合优化问题，将内能E模拟为目标函数值 f，温度T演化成控制参数 t，即得到解组合优化问题的模拟退火演算法：由初始解 i 和控制参数初值 t 开始，对当前解重复“产生新解→计算目标函数差→接受或丢弃”的迭代，并逐步衰减 t 值，算法终止时的当前解即为所得近似最优解。 因此我们归结起来就是以下几点：1) 若f( Y(i+1) ) &lt;= f( Y(i) ) (即移动后得到更优解)，则总是接受该移动；2) 若f( Y(i+1) ) &gt; f( Y(i) ) (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）相当于上图中，从B移向BC之间的小波峰D时，每次右移(即接受一个更糟糕值)的概率在逐渐降低。如果这个坡特别长，那么很有可能最终我们并不会翻过这个坡。如果它不太长，这很有可能会翻过它，这取决于衰减 t 值的设定。 2.4 模拟退火算法伪代码相信通过上面的讲解，大家已经对模拟退火算法认识得差不多了。下面我们来看看它的伪代码是怎么实现的。 03 使用模拟退火算法解决旅行商问题旅行商问题属于所谓的NP完全问题。精确的解决TSP只能通过穷举所有的路径组合，其时间复杂度是O(N!) 。而使用模拟退火算法则可以较快速算法一条近似的最优路径。大体的思路如下： 产生一条新的遍历路径P(i+1)，计算路径P(i+1)的长度L( P(i+1) ) 若L(P(i+1)) &lt; L(P(i))，则接受P(i+1)为新的路径，否则以模拟退火的那个概率接受P(i+1) ，然后降温 重复步骤1，2直到满足退出条件 好了多说无益，下面大家一起看代码吧。基于中国31个城市跑的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/* * 使用模拟退火算法(SA)求解TSP问题(以中国TSP问题为例) * 参考自《Matlab 智能算法30个案例分析》 */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#define T0 50000.0 // 初始温度#define T_end (1e-8)#define q 0.98 // 退火系数#define L 1000 // 每个温度时的迭代次数，即链长#define N 31 // 城市数量int city_list[N]; // 用于存放一个解// 中国31个城市坐标double city_pos[N][2] = &#123; &#123;1304,2312&#125;,&#123;3639,1315&#125;,&#123;4177,2244&#125;,&#123;3712,1399&#125;, &#123;3488,1535&#125;,&#123;3326,1556&#125;,&#123;3238,1229&#125;,&#123;4196,1004&#125;, &#123;4312,790&#125;,&#123;4386,570&#125;,&#123;3007,1970&#125;,&#123;2562,1756&#125;, &#123;2788,1491&#125;,&#123;2381,1676&#125;,&#123;1332,695&#125;, &#123;3715,1678&#125;,&#123;3918,2179&#125;,&#123;4061,2370&#125;, &#123;3780,2212&#125;,&#123;3676,2578&#125;,&#123;4029,2838&#125;, &#123;4263,2931&#125;,&#123;3429,1908&#125;,&#123;3507,2367&#125;, &#123;3394,2643&#125;,&#123;3439,3201&#125;,&#123;2935,3240&#125;, &#123;3140,3550&#125;,&#123;2545,2357&#125;,&#123;2778,2826&#125;, &#123;2370,2975&#125;&#125;;//函数声明double distance(double *,double *); // 计算两个城市距离double path_len(int *); // 计算路径长度void init(); //初始化函数void create_new(); // 产生新解// 距离函数double distance(double * city1,double * city2)&#123; double x1 = *city1; double y1 = *(city1+1); double x2 = *(city2); double y2 = *(city2+1); double dis = sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); return dis;&#125;// 计算路径长度double path_len(int * arr)&#123; double path = 0; // 初始化路径长度 int index = *arr; // 定位到第一个数字(城市序号) for(int i=0;i&lt;N-1;i++) &#123; int index1 = *(arr+i); int index2 = *(arr+i+1); double dis = distance(city_pos[index1-1], city_pos[index2-1]); path += dis; &#125; int last_index = *(arr+N-1); // 最后一个城市序号 int first_index = *arr; // 第一个城市序号 double last_dis = distance(city_pos[last_index-1], city_pos[first_index-1]); path = path + last_dis; return path; // 返回总的路径长度&#125;// 初始化函数void init()&#123; for(int i=0;i&lt;N;i++) city_list[i] = i+1; // 初始化一个解&#125;// 产生一个新解// 此处采用随机交换两个位置的方式产生新的解void create_new()&#123; double r1 = ((double)rand())/(RAND_MAX+1.0); double r2 = ((double)rand())/(RAND_MAX+1.0); int pos1 = (int)(N*r1); //第一个交叉点的位置 int pos2 = (int)(N*r2); int temp = city_list[pos1]; city_list[pos1] = city_list[pos2]; city_list[pos2] = temp; // 交换两个点&#125;// 主函数int main(void)&#123; srand((unsigned)time(NULL)); //初始化随机数种子 time_t start,finish; start = clock(); // 程序运行开始计时 double T; int count = 0; // 记录降温次数 T = T0; //初始温度 init(); //初始化一个解 int city_list_copy[N]; // 用于保存原始解 double f1,f2,df; //f1为初始解目标函数值， //f2为新解目标函数值，df为二者差值 double r; // 0-1之间的随机数，用来决定是否接受新解 while(T &gt; T_end) // 当温度低于结束温度时，退火结束 &#123; for(int i=0;i&lt;L;i++) &#123; // 复制数组 memcpy(city_list_copy,city_list,N*sizeof(int)); create_new(); // 产生新解 f1 = path_len(city_list_copy); f2 = path_len(city_list); df = f2 - f1; // 以下是Metropolis准则 if(df &gt;= 0) &#123; r = ((double)rand())/(RAND_MAX); if(exp(-df/T) &lt;= r) // 保留原来的解 &#123; memcpy(city_list,city_list_copy,N*sizeof(int)); &#125; &#125; &#125; T *= q; // 降温 count++; &#125; finish = clock(); // 退火过程结束 double duration = ((double)(finish-start))/CLOCKS_PER_SEC; // 计算时间 printf(\"模拟退火算法，初始温度T0=%.2f,降温系数q=%.2f,每个温度迭代%d次,共降温%d次，得到的TSP最优路径为:\\n\",T0,q,L,count); for(int i=0;i&lt;N-1;i++) // 输出最优路径 &#123; printf(\"%d---&gt;\",city_list[i]); &#125; printf(\"%d\\n\",city_list[N-1]); double len = path_len(city_list); // 最优路径长度 printf(\"最优路径长度为:%lf\\n\",len); printf(\"程序运行耗时:%lf秒.\\n\",duration); return 0;&#125; 代码运行结果： 04 小结从上面的过程我们可以看出，模拟退火算法是一种随机算法，它有一定的概率能求得全局最优解，但不一定。用模拟退火算法可以较快速地找出问题的最优近似解。它的关键之处还是在于允许一定的差解。不过，在小编不成熟的眼光看来，人生亦有相似之处。有时候可能放弃眼前短浅的利益，最终才可能获得更好的未来。现在失去的，在未来会以另一种方式归来。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"关于图论中的最小生成树(Minimum Spanning Tree)详解","slug":"关于图论中的最小生成树-Minimum-Spanning-Tree-详解","date":"2018-02-18T05:45:50.000Z","updated":"2018-05-05T15:11:02.708Z","comments":true,"path":"2018/02/18/关于图论中的最小生成树-Minimum-Spanning-Tree-详解/","link":"","permalink":"http://yoursite.com/2018/02/18/关于图论中的最小生成树-Minimum-Spanning-Tree-详解/","excerpt":"本节纲要 什么是图(network) 什么是最小生成树 (minimum spanning tree) 最小生成树的算法","text":"本节纲要 什么是图(network) 什么是最小生成树 (minimum spanning tree) 最小生成树的算法 什么是图(network)？这里的图当然不是我们日常说的图片或者地图。通常情况下，我们把图看成是一种由“顶点”和“边”组成的抽象网络。在各个“顶点“间可以由”边“连接起来，使两个顶点间相互关联起来。图的结构可以描述多种复杂的数据对象，应用较为广泛，看下图： 为了更好地说明问题，下面我们看一个比较老套的通信问题： 在各大城市中建设通信网络，如下图所示，每个圆圈代表一座城市，而边上的数字代表了建立通信连接的价格。那么，请问怎样才能以最小的价格使各大城市能直接或者间接地连接起来呢？ 我们需要注意两点： 最小的价格 各大城市可以是直接或者间接相连的 稍稍留心可以发现，题目的要求是，城市只需要直接或者间接相连，因此，为了节省成本，我们稍稍优化一下上述方案如下： 可以看到，我们砍掉了原先在AD，BE之间的两条道路，建设价格自然就降下来了。当然这个方案也是符合我们题目的要求的。按照国际惯例，这里要说蛋是了。上面的实例由于数据很简单，优化的方案很easy就看出来了。但在实际中，数据量往往是非常庞大的。所以，我们更倾向于设计一种方法，然后利用计算机强大的运算能力帮我们处理这些数据得出最优的方案。那么，针对上述问题，我们一起来看看如何应用图的相关知识来实现吧。 什么是最小生成树(minimum spanning tree)为了直观，还是用图片给大家解释一下： 对于一个图而言，它可以生成很多树，如右侧图2，图3就是由图1生成的。 从上面可以看出生成树是将原图的全部顶点以最少的边连通的子图，对于有n个顶点的连通图，生成树有n-1条边，若边数小于此数就不可能将各顶点连通，如果边的数量多于n-1条边，必定会产生回路。 对于一个带权连通图，生成树不同，树中各边上权值总和也不同，权值总和最小的生成树则称为图的最小生成树。 关于最小生成树的算法(Prim算法和Kruskal算法)Prim算法基本思想：假设有一个无向带权图G=(V,E)，它的最小生成树为MinTree=(V,T)，其中V为顶点集合，T为边的集合。求边的集合T的步骤如下： ①令 U={u0}，T={}。其中U为最小生成树的顶点集合，开始时U中只含有顶点u0（u0可以为集合V中任意一项），在开始构造最小生成树时我们从u0出发。 ②对所有u∈U，v∈(V – U)（其中u,v表示顶点）的边(u,v)中，找一条权值最小的边(u’,v’)，将这条边加入到集合T中，将顶点v’加入集合U中。 ③直到将V中所有顶点加入U中，则算法结束，否则一直重复以上两步。 ④符号说明：我们用大写字母表示集合，用小写字母表示顶点元素，用&lt;&gt;表示两点之间的边。 为了更好的说明问题，我们下面一步一步来为大家展示这个过程。 初始状态：U={a} V={b,c,d,e } T={} 集合U和V相关联的权值最小的边是，于是我们将b加入U。U={a,b}，V={d,c,e }，T={} 此时集合U和V相关联的权值最小的边是，于是我们将c加入U。U={a,b,c} ，V={d,e }，T={, } 显然此时集合U和V中相关联的权值最小的边是，于是我们将d加入U。U={a,b,c,d} ，V={e }，T={, ,} 最后集合U和V中相关联的权值最小的边是，于是将e加入U。U={a,b,c,d,e} ，V={}，T={, ,,}。到此所有点访问完毕。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//prime算法//将城市X标记为visit=true时，就表示该城市加入到集合U，用sum累加记录边的总费用#include&lt;iostream&gt;#define NO 99999999 //99999999代表两点之间不可达#define N 5using namespace std;bool visit[N];long long money[N] = &#123; 0 &#125;;long long graph[N][N] = &#123;0&#125;;void initgraph()&#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; scanf(\" %lld\", &amp;graph[i][j]); &#125; &#125; &#125;void printgraph()&#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; printf(\" %lld\", graph[i][j]); &#125; &#125;&#125;int prim(int city)&#123; initgraph(); printgraph(); int index = city; int sum = 0; int i = 0; int j = 0; cout &lt;&lt;\"访问节点：\" &lt;&lt;index &lt;&lt; \"\\n\"; memset(visit, false, sizeof(visit)); visit[city] = true; for (i = 0; i &lt; N; i++) &#123; money[i] = graph[city][i];//初始化，每个与城市city间相连的费用存入money，以便后续比较 &#125; for (i = 1; i &lt; N; i++) &#123; int minor = NO; for (j = 0; j &lt; N; j++) &#123; if ((visit[j] == false) &amp;&amp; money[j] &lt; minor) //找到未访问的城市中，与当前最小生成树中的城市间费用最小的城市 &#123; minor = money[j]; index = j; &#125; &#125; visit[index] = true; cout &lt;&lt; \"访问节点：\" &lt;&lt; index &lt;&lt; \"\\n\"; sum += minor; //求总的最低费用 /*这里是一个更新，如果未访问城市与当前城市间的费用更低，就更新money,保存更低的费用*/ for (j = 0; j &lt; N; j++) &#123; if ((visit[j] == false) &amp;&amp; money[j]&gt;graph[index][j]) &#123; money[j] = graph[index][j]; &#125; &#125; &#125; cout &lt;&lt; endl; return sum; //返回总费用最小值&#125;int main()&#123; cout &lt;&lt; \"修路最低总费用为：\"&lt;&lt; prim(0) &lt;&lt; endl;//从城市0开始 return 0;&#125; Kruskal算法解最小生成树的另一种常见的算法是Kruskal算法，它比Prim算法更直观。Kruskal算法的做法是：每次都从剩余边中选取权值最小的，当然，这条边不能使已有的边产生回路。手动求解会发现Kruskal算法异常简单，下面是一个例子 先对边的权值排个序：1(V0,V4)、2(V2,V6)、4(V1,V3)、6(V1,V2)、8(V3,V6)、10(V5,V6)、12(V3,V5)、15(V4,V5)、20(V0,V1) 首选边1(V0,V4)、2(V2,V6)、4(V1,V3)、6(V1,V2)，此时的图是这样 显然，若选取边8(V3,V6)则会出现环，则必须抛弃8(V3,V6)，选择下一条10(V5,V6)没有问题，此时图变成这样 显然，12(V3,V5)同样不可取，选取15(V4,V5)，边数已达到要求，算法结束。最终的图是这样的算法逻辑很容易理解，但用代码判断当前边是否会引起环的出现则很棘手。这里简单提一提连通分量 在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，将其中较大的连通子图称为连通分量。 在有向图中，如果对于每一对顶点vi和vj，从vi到vj和从vj到vi都有路径，则称该图为强连通图；否则，将其中的极大连通子图称为强连通分量。 算法说明为了判断环的出现，我们换个角度来理解Kruskal算法的做法：初始时，把图中的n个顶点看成是独立的n个连通分量，从树的角度看，也是n个根节点。我们选边的标准是这样的：若边上的两个顶点从属于两个不同的连通分量，则此边可取，否则考察下一条权值最小的边。于是问题又来了，如何判断两个顶点是否属于同一个连通分量呢？这个可以参照并查集的做法解决。它的思路是：如果两个顶点的根节点是一样的，则显然是属于同一个连通分量。这也同样暗示着：在加入新边时，要更新父节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//kruskal算法#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;#include&lt;vector&gt;using namespace std;#define N 10005#define M 50005#define qm 100005#define INF 2147483647struct arr&#123; int ff, tt, ww;&#125;c[M &lt;&lt; 1];// 存储边的集合，ff，tt，ww为一条从ff连接到tt的权值为ww的边 int tot = 0;//边的总数 int ans = 0;//最小生成树的权值和 int f[N];//并查集 bool comp(const arr &amp; a, const arr &amp; b)&#123; return a.ww &lt; b.ww;&#125;int m, n;//边数量，点数量 int getfa(int x)&#123; return f[x] == x ? x : f[x] = getfa(f[x]);&#125;//并查集，带路径压缩 inline void add(int x, int y, int z)&#123; c[++tot].ff = x; c[tot].tt = y; c[tot].ww = z; return;&#125;//新增一条边 void kruscal()&#123; for (int i = 1; i &lt;= n; i ++) f[i] = i; for (int i = 1; i &lt;= m; i ++)&#123; int fx = getfa(c[i].ff);//寻找祖先 int fy = getfa(c[i].tt); if (fx != fy)&#123;//不在一个集合，合并加入一条边 f[fx] = fy; ans += c[i].ww; &#125; &#125; return;&#125; int main()&#123; freopen(\"input10.txt\", \"r\", stdin); freopen(\"output10.txt\", \"w\", stdout); scanf(\"%d%d\",&amp;n, &amp;m); int x, y, z; for (int i = 1; i &lt;= m; i ++)&#123; scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;z); add(x, y, z); &#125; sort(c + 1, c + 1 + m, comp);//快速排序 kruscal(); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"用回溯法(backtracking algorithm)求解N皇后问题(N-Queens puzzle)","slug":"用回溯法-backtracking-algorithm-求解N皇后问题-N-Queens-puzzle","date":"2018-02-18T05:26:19.000Z","updated":"2018-05-05T15:10:44.576Z","comments":true,"path":"2018/02/18/用回溯法-backtracking-algorithm-求解N皇后问题-N-Queens-puzzle/","link":"","permalink":"http://yoursite.com/2018/02/18/用回溯法-backtracking-algorithm-求解N皇后问题-N-Queens-puzzle/","excerpt":"什么是N-皇后问题?说到这个N-皇后问题，就不得不先提一下这个历史上著名的8皇后问题啦。 八皇后问题，是一个古老而著名的问题.该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法?","text":"什么是N-皇后问题?说到这个N-皇后问题，就不得不先提一下这个历史上著名的8皇后问题啦。 八皇后问题，是一个古老而著名的问题.该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法? 那么，我们将8皇后问题推广一下，就可以得到我们的N皇后问题了。N皇后问题是一个经典的问题，在一个NxN的棋盘上放置N个皇后，使其不能互相攻击 (同一行、同一列、同一斜线上的皇后都会自动攻击) 那么问，有多少种摆法？ 回溯算法(backtracking algorithm)N皇后问题其实就是回溯算法中的一个典型应用。为此，在这里先介绍一下回溯算法。 定义(参考至百度百科) 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 基本思想 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 什么是深度优先搜索？ 深度优先搜索(DFS即Depth First Search)其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 解决问题的一般步骤 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。 确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。 解空间和解空间树 解空间一个复杂问题的解决往往由多部分构成，那么，一个大的解决方案就可以看成是由若干个小的决策组成。很多时候它们构成一个决策序列。解决一个问题的所有可能的决策序列构成该问题的解空间。解空间中满足约束条件的决策序列称为可行解。一般说来，解任何问题都有一个目标，在约束条件下使目标值达到最大（或最小）的可行解称为该问题的最优解。在解空间中，前k项决策已经取定的所有决策序列之集，称为k定子解空间。0定子解空间即是该问题的解空间。这个空间必须至少包含一个解（可能是最优的）。 解空间树因为回溯方法的基本思想是通过搜索解空间来找到问题所要求的解，所以如何组织解空间的结构会直接影响对问题的求解效率。一般地，我们可以用一棵树来描述解空间，并称之为解空间树。 算法框架 针对N叉树的递归回溯方法 123456789101112131415161718//针对N叉树的递归回溯方法 void backtrack (int t)&#123; if (t&gt;n) &#123; output(x); //叶子节点，输出结果，x是可行解 &#125; else &#123; for i = 1 to k//当前节点的所有子节点 &#123; x[t]=value(i); //每个子节点的值赋值给x //满足约束条件和限界条件 if (constraint(t)&amp;&amp;bound(t)) backtrack(t+1); //递归下一层 &#125; &#125;&#125; 针对N叉树的迭代回溯方法 12345678910111213141516171819202122232425//针对N叉树的迭代回溯方法void iterativeBacktrack () &#123; int t=1; while (t&gt;0) &#123; if(ExistSubNode(t)) //当前节点的存在子节点 &#123; for i = 1 to k //遍历当前节点的所有子节点 &#123; x[t]=value(i);//每个子节点的值赋值给x if (constraint(t)&amp;&amp;bound(t))//满足约束条件和限界条件 &#123; //solution表示在节点t处得到了一个解 if (solution(t)) output(x);//得到问题的一个可行解，输出 else t++;//没有得到解，继续向下搜索 &#125; &#125; &#125; else //不存在子节点，返回上一层 t--; &#125; &#125; N皇后问题的solve算法伪代码描述下面是算法的高级伪码描述，这里用一个N*N的矩阵来存储棋盘： 1) 算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列 2) 在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第4步 3) 在当前位置上满足条件的情形： 在当前位置放一个皇后，若当前行是最后一行，记录一个解； 若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置； 若当前行是最后一行，当前列不是最后一列，当前列设为下一列； 若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置。 以上返回到第2步 4) 在当前位置上不满足条件的情形： 若当前列不是最后一列，当前列设为下一列，返回到第2步; 若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步; 图解问题过程为了让大家更好理解，这里画了一张图。 coding time我们之前说过N皇后问题是回溯算法的经典应用。因此我们可以使用回溯法来解决该问题，具体实现也有两个途径，递归和非递归。 递归法其实递归法算是比较简单的了。我们使用一个一维数组来存储棋盘。具体细节如下：把棋盘存储为一个一维数组a[N]，数组中第i个元素的值代表第i行的皇后位置。在判断是否冲突时也很简单： 首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了。 其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。 至于斜线冲突，通过观察可以发现所有在斜线上冲突的皇后的位置都有规律。即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const int N=20; //最多放皇后的个数int q[N]; //i表示皇后所在的行号， //q[i]表示皇后所在的列号int cont = 0; //统计解的个数//输出一个解void print(int n)&#123; int i,j; cont++; printf(\"第%d个解：\",cont); for(i=1;i&lt;=n;i++) printf(\"(%d,%d) \",i,q[i]); printf(\"\\n\"); for(i=1;i&lt;=n;i++) //行 &#123; for(j=1;j&lt;=n;j++) //列 &#123; if(q[i]!=j) printf(\"x \"); else printf(\"Q \"); &#125; printf(\"\\n\"); &#125;&#125;//检验第i行的k列上是否可以摆放皇后int find(int i,int k)&#123; int j=1; while(j&lt;i) //j=1~i-1是已经放置了皇后的行 &#123; //第j行的皇后是否在k列或(j,q[j])与(i,k)是否在斜线上 if(q[j]==k || abs(j-i)==abs(q[j]-k)) return 0; j++; &#125; return 1;&#125;//放置皇后到棋盘上void place(int k,int n)&#123; int j; if(k&gt;n) print(n); //递归出口 else &#123; for(j=1;j&lt;=n;j++) //试探第k行的每一个列 &#123; if(find(k,j)) &#123; q[k] = j; //保存位置 place(k+1,n); //接着下一行 &#125; &#125; &#125;&#125;int main1111(void)&#123; int n; printf(\"请输入皇后的个数(n&lt;=20),n=:\"); scanf(\"%d\",&amp;n); if(n&gt;20) printf(\"n值太大，不能求解!\\n\"); else &#123; printf(\"%d皇后问题求解如下(每列的皇后所在的行数):\\n\",n); place(1,n); //问题从最初状态解起 printf(\"\\n\"); &#125; system(\"pause\"); return 0;&#125; 迭代法为什么还要迭代呢？因为递归效率有时候并不是那么的高。具体思路：首先对N行中的每一行进行探测，查找该行中可以放皇后的位置。具体怎么做呢？ 首先对该行的逐列进行探测，看是否可以放置皇后，如果可以，则在该列放置一个皇后，然后继续探测下一行的皇后位置。 如果已经探测完所有的列都没有找到可以放置皇后的列，这时候就应该回溯了，把上一行皇后的位置往后移一列。 如果上一行皇后移动后也找不到位置，则继续回溯直至某一行找到皇后的位置或回溯到第一行，如果第一行皇后也无法找到可以放置皇后的位置，则说明已经找到所有的解，程序终止。 如果该行已经是最后一行，则探测完该行后，如果找到放置皇后的位置，则说明找到一个结果，打印出来。 但是此时并不能在此处结束程序，因为我们要找的是所有N皇后问题所有的解，此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。 由此可见，非递归方法的一个重要问题时何时回溯及如何回溯的问题。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define QUEEN 8 //皇后的数目#define INITIAL -10000 //棋盘的初始值int a[QUEEN]; //一维数组表示棋盘void init() //对棋盘进行初始化&#123; int *p; for (p = a; p &lt; a + QUEEN; ++p) &#123; *p = INITIAL; &#125;&#125;int valid(int row, int col) //判断第row行第col列是否可以放置皇后&#123; int i; for (i = 0; i &lt; QUEEN; ++i) //对棋盘进行扫描 &#123; //判断列冲突与斜线上的冲突 if (a[i] == col || abs(i - row) == abs(a[i] - col)) return 0; &#125; return 1;&#125;void print() //打印输出N皇后的一组解&#123; int i, j; for (i = 0; i &lt; QUEEN; ++i) &#123; for (j = 0; j &lt; QUEEN; ++j) &#123; if (a[i] != j) //a[i]为初始值 printf(\"%c \", '.'); else //a[i]表示在第i行的第a[i]列可以放置皇后 printf(\"%c \", '#'); &#125; printf(\"\\n\"); &#125; for (i = 0; i &lt; QUEEN; ++i) printf(\"%d \", a[i]); printf(\"\\n\"); printf(\"--------------------------------\\n\");&#125;void queen() //N皇后程序&#123; int n = 0; int i = 0, j = 0; while (i &lt; QUEEN) &#123; while (j &lt; QUEEN) //对i行的每一列进行探测，看是否可以放置皇后 &#123; if(valid(i, j)) //该位置可以放置皇后 &#123; a[i] = j; //第i行放置皇后 j = 0; //第i行放置皇后以后，需要继续探测下一行的皇后位置， //所以此处将j清零，从下一行的第0列开始逐列探测 break; &#125; else &#123; ++j; //继续探测下一列 &#125; &#125; if(a[i] == INITIAL) //第i行没有找到可以放置皇后的位置 &#123; if (i == 0) //回溯到第一行，仍然无法找到可以放置皇后的位置， //则说明已经找到所有的解，程序终止 break; else //没有找到可以放置皇后的列，此时就应该回溯 &#123; --i; j = a[i] + 1; //把上一行皇后的位置往后移一列 a[i] = INITIAL; //把上一行皇后的位置清除，重新探测 continue; &#125; &#125; if (i == QUEEN - 1) //最后一行找到了一个皇后位置， //说明找到一个结果，打印出来 &#123; printf(\"answer %d : \\n\", ++n); print(); //不能在此处结束程序，因为我们要找的是N皇后问题的所有解， //此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。 j = a[i] + 1; //从最后一行放置皇后列数的下一列继续探测 a[i] = INITIAL; //清除最后一行的皇后位置 continue; &#125; ++i; //继续探测下一行的皇后位置 &#125;&#125;int main(void)&#123; init(); queen(); system(\"pause\"); return 0;&#125; 注：资料整合自网络。 ================================END==================================","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"数据结构-单循环链表代码(C++类模板封装)","slug":"数据结构-单循环链表代码-C-类模板封装","date":"2018-02-18T05:23:21.000Z","updated":"2018-05-05T15:04:28.474Z","comments":true,"path":"2018/02/18/数据结构-单循环链表代码-C-类模板封装/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-单循环链表代码-C-类模板封装/","excerpt":"循环链表就是末尾指向头形成一个循环的链表.实现思路也很简单,大体把单链表代码做个小小的改动就OK了.这次还是封装在一个类里面吧.","text":"循环链表就是末尾指向头形成一个循环的链表.实现思路也很简单,大体把单链表代码做个小小的改动就OK了.这次还是封装在一个类里面吧. CircleLinkList.h 类头文件,各种声明定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma once //VC防止头文件重复包含的一条预编译指令#define status bool#define OK true#define ERROR false#define YES true#define NO falsetemplate &lt;typename DType&gt;class Node&#123;public: DType data; Node * pnext;&#125;;template &lt;typename DType&gt;class CCircleLinkList&#123;private: Node&lt;DType&gt; *phead;public: CCircleLinkList(); ~CCircleLinkList();public: //初始化链表 status InitCList(); //获取链表长度 int GetCListLength(); //增加一个节点 前插法 status AddCListNodeFront(DType idata); //增加一个节点 后插法 status AddCListNodeBack(DType idata); //判断链表是否为空 status IsCListEmpty(); //获取指定位置节点值(注意，本程序规定0号为头节点，e获取删除元素) status GetCListIndexNode(DType *e, int index); //删除指定位置节点(e获取删除元素) status DeleteCListIndexNode(DType *e, int index); //查找链表中指定值(pindex获取位置0==&gt;not found) status SearchCListNode(DType SData, int *pindex); //指定位置前插 status InsertCListNodeFront(DType IData, int index); //指定位置后插 status InsertCListNodeBack(DType IData, int index); //清空链表(保留根节点) status ClearCList(); //销毁链表(all delete) status DestoryCList(); //尾部删除一个元素 status DeleteCListNodeBack(); //打印链表 此函数根据实际情况而定 void PrintCList();&#125;; CircleLinkList.cpp 类的具体实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286#include \"CircleLinkList.h\"#include &lt;stdio.h&gt;template &lt;typename DType&gt;CCircleLinkList&lt;DType&gt;::CCircleLinkList()&#123; cout &lt;&lt; \"链表创建\" &lt;&lt; endl; InitCList();&#125;template &lt;typename DType&gt;CCircleLinkList&lt;DType&gt;::~CCircleLinkList()&#123; cout &lt;&lt; \"链表销毁\" &lt;&lt; endl; DestoryCList();&#125;//初始化链表template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::InitCList()&#123; Node&lt;DType&gt; * ph = new Node&lt;DType&gt;; if (ph != NULL) &#123; ph-&gt;pnext = ph; //尾指向头 this-&gt;phead = ph; //头结点 return OK; &#125; return ERROR;&#125;//获取链表长度(head_node is not included)template &lt;typename DType&gt;int CCircleLinkList&lt;DType&gt;::GetCListLength()&#123; int length = 0; Node&lt;DType&gt; * ph = this-&gt;phead; while (ph-&gt;pnext != this-&gt;phead) &#123; length++; ph = ph-&gt;pnext; &#125; return length;&#125;//增加一个节点 前插法template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::AddCListNodeFront(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; if (pnode != NULL) &#123; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead-&gt;pnext; this-&gt;phead-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//增加一个节点 尾插法template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::AddCListNodeBack(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; Node&lt;DType&gt; * ph = this-&gt;phead; if (pnode != NULL) &#123; while (ph-&gt;pnext != this-&gt;phead) &#123; ph = ph-&gt;pnext; &#125; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead; ph-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//判断链表是否为空template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::IsCListEmpty()&#123; if (this-&gt;phead-&gt;pnext == this-&gt;phead) &#123; return YES; &#125; return NO;&#125;//获取指定位置节点值(注意，本程序规定0号为头节点，e获取节点的值)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::GetCListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; int i = 0; //计数器 if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; while (ph-&gt;pnext != this-&gt;phead) &#123; i++; ph = ph-&gt;pnext; if (i == index) &#123; *e = ph-&gt;data; return OK; &#125; &#125; return ERROR;&#125;//删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::DeleteCListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; while (ph-&gt;pnext != this-&gt;phead) &#123; i++; q = ph; //保存备用 ph = ph-&gt;pnext; if (i == index) &#123; *e = ph-&gt;data; q-&gt;pnext = ph-&gt;pnext; //删除出局 delete ph; return OK; &#125; &#125; return ERROR;&#125;//查找链表中指定值(pindex获取位置 0==&gt;not found)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::SearchCListNode(DType SData, int *pindex)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; int iCount = 0;//计数器 while (ph-&gt;pnext != this-&gt;phead) &#123; iCount++; ph = ph-&gt;pnext; if (ph-&gt;data == SData) &#123; *pindex = iCount; return YES; &#125; &#125; *pindex = 0; return NO;&#125;//指定位置前插template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::InsertCListNodeFront(DType IData, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (ph-&gt;pnext != this-&gt;phead) &#123; iCount++; q = ph; ph = ph-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = ph; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125;//指定位置后插template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::InsertCListNodeBack(DType IData, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (ph-&gt;pnext != this-&gt;phead) &#123; iCount++; q = ph; ph = ph-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = ph; ph = ph-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = ph; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125;//清空链表(保留根节点)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::ClearCList()&#123; Node&lt;DType&gt; * ph = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //防止那啥，野指针 ph = ph-&gt;pnext;//保留头节点 while (ph != this-&gt;phead) &#123; q = ph; ph = ph-&gt;pnext; delete q; //释放 &#125; this-&gt;phead-&gt;pnext = this-&gt;phead; return OK;&#125;//销毁链表(all delete)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::DestoryCList()&#123; ClearCList(); delete this-&gt;phead;//释放头结点 return OK;&#125;template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::DeleteCListNodeBack()&#123; Node&lt;DType&gt; * ph = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //备用 if (ph-&gt;pnext == this-&gt;phead) &#123; return ERROR; //链表都空了还删鸡毛 &#125; while (ph-&gt;pnext != this-&gt;phead) &#123; q = ph; ph = ph-&gt;pnext; &#125; q-&gt;pnext = this-&gt;phead; delete ph; return OK;&#125;template &lt;typename DType&gt;void CCircleLinkList&lt;DType&gt;::PrintCList()&#123; Node&lt;DType&gt; * ph = this-&gt;phead; if (ph-&gt;pnext == this-&gt;phead) &#123; cout &lt;&lt; \"链表为空，打印鸡毛\" &lt;&lt; endl; return; &#125; int i = 1; cout &lt;&lt; \"===============print list================\" &lt;&lt; endl; while (ph-&gt;pnext != this-&gt;phead) &#123; ph = ph-&gt;pnext; cout &lt;&lt; \"node[\" &lt;&lt; i++ &lt;&lt; \"] = \" &lt;&lt; ph-&gt;data &lt;&lt; endl; &#125;&#125; CircleLinkListTest.cpp 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include \"CircleLinkList.h\"#include \"CircleLinkList.cpp\"using namespace std;int main()&#123; CCircleLinkList&lt;int&gt; * pMySList = new CCircleLinkList&lt;int&gt;; cout &lt;&lt; pMySList-&gt;IsCListEmpty() &lt;&lt; endl; pMySList-&gt;AddCListNodeFront(111); pMySList-&gt;AddCListNodeFront(222); pMySList-&gt;AddCListNodeFront(333); cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetCListLength() &lt;&lt; endl; pMySList-&gt;PrintCList(); pMySList-&gt;AddCListNodeBack(444); pMySList-&gt;AddCListNodeBack(555); pMySList-&gt;AddCListNodeBack(666); pMySList-&gt;PrintCList(); cout &lt;&lt; pMySList-&gt;IsCListEmpty() &lt;&lt; endl; cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetCListLength() &lt;&lt; endl; int GetElem, GetIndex; pMySList-&gt;GetCListIndexNode(&amp;GetElem, 2); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetCListIndexNode(&amp;GetElem, 6); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetCListIndexNode(&amp;GetElem, 4); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteCListIndexNode(&amp;GetElem, 1); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteCListIndexNode(&amp;GetElem, 3); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;PrintCList(); pMySList-&gt;SearchCListNode(555, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchCListNode(111, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchCListNode(666, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;InsertCListNodeFront(333, 1); pMySList-&gt;InsertCListNodeFront(444, 4); pMySList-&gt;PrintCList(); pMySList-&gt;InsertCListNodeBack(777, 3); pMySList-&gt;InsertCListNodeBack(888, 5); pMySList-&gt;PrintCList(); pMySList-&gt;DeleteCListNodeBack(); pMySList-&gt;PrintCList(); pMySList-&gt;DeleteCListNodeBack(); pMySList-&gt;PrintCList(); pMySList-&gt;DeleteCListNodeBack(); pMySList-&gt;PrintCList(); return 0;&#125; 代码未经严谨测试,如果有误,欢迎指正.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-静态链表代码(C++类模板封装)","slug":"数据结构-静态链表代码-C-类模板封装","date":"2018-02-18T05:21:42.000Z","updated":"2018-05-05T15:05:12.650Z","comments":true,"path":"2018/02/18/数据结构-静态链表代码-C-类模板封装/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-静态链表代码-C-类模板封装/","excerpt":"熬了一个下午,终于写完了.哈哈,用了C++的类模板封装了一个静态链表,简单的增删查改功能都有了.具体可以看代码。","text":"熬了一个下午,终于写完了.哈哈,用了C++的类模板封装了一个静态链表,简单的增删查改功能都有了.具体可以看代码。 StaticLinkList.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include &lt;iomanip&gt;#define MAXSIZE 100#define status bool#define YES true#define NO false#define OK true#define ERROR falsetemplate &lt;typename DATATYPE&gt;class Component&#123;public: DATATYPE data; //数据域 int cur; //cur域，指向下一个元素的下标&#125;;template &lt;typename DATATYPE&gt;class CStaticLinkList&#123;public: Component&lt;DATATYPE&gt; StaticLinkList[MAXSIZE]; //静态表//自定义malloc和freepublic: int MallocNodeSSL(); status FreeNodeSSL(int index);public: status InitList(); //初始化静态表 status BackAddList( DATATYPE AddData); //尾增加 status InsertNodeList(DATATYPE InsertData, int index);//指定位置插入 status DeleteNodeList(DATATYPE *DelData, int index); //指定位置删除 int SearchList(DATATYPE sData); //搜索数据为sData的节点,返回其在数组中的下标,0表示失败 status GetIndexList(DATATYPE *gData, int index);//获取指定索引的节点数据 int GetLengthList(); //获取静态表的长度 status ClearList(); //清空静态表 status IsEmptyList(); //判断静态表是否为空 status IsFullList(); //判断静态表是否满了 void PrintList(); //打印静态表,此函数根据实际情况编写public: CStaticLinkList(); ~CStaticLinkList();&#125;; StaticLinkList.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#include \"StaticLinkList.h\"template &lt;typename DATATYPE&gt;CStaticLinkList&lt;DATATYPE&gt;::CStaticLinkList()&#123; cout &lt;&lt; \"===========静态表创建===========\" &lt;&lt; endl; InitList();&#125;template &lt;typename DATATYPE&gt;CStaticLinkList&lt;DATATYPE&gt;::~CStaticLinkList()&#123; cout &lt;&lt; \"===========静态表销毁===========\" &lt;&lt; endl;&#125;template &lt;typename DATATYPE&gt;int CStaticLinkList&lt;DATATYPE&gt;::MallocNodeSSL()&#123; int index = StaticLinkList[0].cur; //把备用链表第一个节点拿出来用 if (StaticLinkList[0].cur) //判断是否还有位置 &#123; StaticLinkList[0].cur = StaticLinkList[index].cur; //让备用链表第二个节点上来顶替第一个的位置 &#125; return index; //返回0表示分配失败&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::FreeNodeSSL(int index)&#123; //将删除节点挂接到备用链表上 this-&gt;StaticLinkList[index].cur = this-&gt;StaticLinkList[0].cur; this-&gt;StaticLinkList[0].cur = index; return OK;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::InitList()&#123; int i; for (i = 0; i &lt; MAXSIZE - 1; i++) &#123; StaticLinkList[i].cur = i + 1;//全部塞入备用链表 &#125; StaticLinkList[MAXSIZE - 1].cur = 0;/*因为目前静态表为空,最后一个节点的cur域为0*/ return OK;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::BackAddList(DATATYPE AddData) //尾增加&#123; if (IsFullList()) &#123; return ERROR; &#125; int index = MAXSIZE - 1; int last = index; while (index != 0) &#123; last = index; index = StaticLinkList[index].cur; &#125; int k = MallocNodeSSL(); //获取空闲位置下标 if (k) &#123; StaticLinkList[k].data = AddData; //存入数据 StaticLinkList[k].cur = 0; //末尾指向0 StaticLinkList[last].cur = k; return OK; &#125; return ERROR; &#125;//在List中第i个节点之前插入新的节点template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::InsertNodeList(DATATYPE InsertData, int index)//指定位置插入&#123; int i, GetFree, pos; pos = MAXSIZE - 1;//最后节点下标 if (index &lt; 1 || index &gt; GetLengthList() || IsFullList()) &#123; return ERROR; //位置异常处理 &#125; GetFree = MallocNodeSSL(); if (GetFree) &#123; StaticLinkList[GetFree].data = InsertData; for (i = 0; i &lt; index - 1; i++) &#123; pos = StaticLinkList[pos].cur; //定位 &#125; StaticLinkList[GetFree].cur = StaticLinkList[pos].cur; StaticLinkList[pos].cur = GetFree; //插入 int q = StaticLinkList[MAXSIZE - 1].cur; if (q == 0) //静态表为空 &#123; StaticLinkList[MAXSIZE - 1].cur = 1; &#125; return OK; &#125; return ERROR;&#125;//判断是否为空template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::IsEmptyList()&#123; if (StaticLinkList[MAXSIZE-1].cur == 0) &#123; return YES; &#125; return NO;&#125;//判断静态表是否满了template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::IsFullList()&#123; if (GetLengthList() == MAXSIZE - 2) //因为首位不存数据,因此pass掉 &#123; return YES; &#125; return NO;&#125;template &lt;typename DATATYPE&gt;int CStaticLinkList&lt;DATATYPE&gt;::GetLengthList() //获取静态表的长度&#123; int iCount = 0; int k = MAXSIZE - 1; while (StaticLinkList[k].cur != 0) &#123; iCount++; k = StaticLinkList[k].cur; &#125; return iCount;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::DeleteNodeList(DATATYPE *DelData, int index)//指定位置删除&#123; int i, pos, k; pos = MAXSIZE - 1;//最后节点下标 if (index &lt; 1 || index &gt; GetLengthList() || IsEmptyList()) &#123; return ERROR; //位置异常处理 &#125; for (i = 0; i &lt; index - 1; i++) &#123; pos = StaticLinkList[pos].cur; //定位到被删除节点的前一个节点 &#125; k = StaticLinkList[pos].cur; *DelData = StaticLinkList[k].data; //获取数据 StaticLinkList[pos].cur = StaticLinkList[k].cur;//让前一个节点直接指向后一个节点.把夹在中间的踢掉 FreeNodeSSL(k); //释放空间 return OK;&#125;//搜索数据为sData的节点,返回其在静态表中的第i个位置,0表示没找到template &lt;typename DATATYPE&gt;int CStaticLinkList&lt;DATATYPE&gt;::SearchList(DATATYPE sData)&#123; int pos = StaticLinkList[MAXSIZE-1].cur; int iCount = 1; while (pos != 0) &#123; if (StaticLinkList[pos].data == sData) //找到数据 &#123; return iCount; &#125; pos = StaticLinkList[pos].cur; //循环遍历 iCount++; &#125; return 0;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::GetIndexList(DATATYPE *gData, int index)//获取第index个节点数据&#123; int i, pos; pos = MAXSIZE - 1;//最后节点下标 if (index &lt; 1 || index &gt; GetLengthList() || IsEmptyList()) &#123; return ERROR; //位置异常处理 &#125; for (i = 0; i &lt; index; i++) &#123; pos = StaticLinkList[pos].cur; //定位到第index个节点 &#125; *gData = StaticLinkList[pos].data; return OK;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::ClearList() //清空静态表&#123; InitList();//再初始化一次就是清空了 return OK;&#125;template &lt;typename DATATYPE&gt;void CStaticLinkList&lt;DATATYPE&gt;::PrintList()&#123; int pos = StaticLinkList[MAXSIZE - 1].cur; if (pos == 0) &#123; cout &lt;&lt; \"===========静态链表为空,打印鸡毛!!!===========\" &lt;&lt; endl; return; &#125; cout &lt;&lt; setiosflags(ios::left); cout &lt;&lt; setw(10) &lt;&lt; \"索引\" &lt;&lt; setw(10) &lt;&lt; \"下标\" &lt;&lt; setw(10) &lt;&lt; \"data\" &lt;&lt; setw(10) &lt;&lt; \"cur\" &lt;&lt; endl; int iCount = 1; while (pos != 0) &#123; cout &lt;&lt; setw(10) &lt;&lt; iCount &lt;&lt; setw(10) &lt;&lt; pos &lt;&lt; setw(10) &lt;&lt; StaticLinkList[pos].data &lt;&lt; setw(10) &lt;&lt; StaticLinkList[pos].cur &lt;&lt; endl; pos = StaticLinkList[pos].cur; //循环遍历 iCount++; &#125;&#125; StaticLinkListTest.cpp测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;iomanip&gt;#include \"StaticLinkList.h\"#include \"StaticLinkList.cpp\"using namespace std;int main()&#123; char get; CStaticLinkList&lt;char&gt; *p = new CStaticLinkList&lt;char&gt;; p-&gt;PrintList(); p-&gt;BackAddList('a'); //pass p-&gt;BackAddList('b'); p-&gt;BackAddList('c'); p-&gt;BackAddList('d'); p-&gt;BackAddList('e'); //p-&gt;ClearList(); //pass p-&gt;PrintList(); p-&gt;DeleteNodeList(&amp;get, 2); //pass cout &lt;&lt; \"get = \" &lt;&lt; get &lt;&lt; endl; p-&gt;DeleteNodeList(&amp;get, 2); cout &lt;&lt; \"get = \" &lt;&lt; get &lt;&lt; endl; p-&gt;PrintList(); p-&gt;BackAddList('f'); p-&gt;PrintList(); cout &lt;&lt; \"length = \" &lt;&lt; p-&gt;GetLengthList() &lt;&lt; endl;//pass p-&gt;GetIndexList(&amp;get, 3); //pass cout &lt;&lt; \"get = \" &lt;&lt; get &lt;&lt; endl; p-&gt;InsertNodeList('h', 2); p-&gt;InsertNodeList('i', 3); p-&gt;PrintList(); cout &lt;&lt; \"length = \" &lt;&lt; p-&gt;GetLengthList() &lt;&lt; endl;//pass cout &lt;&lt; \"search_pos = \" &lt;&lt; p-&gt;SearchList('q') &lt;&lt; endl; cout &lt;&lt; \"search_pos = \" &lt;&lt; p-&gt;SearchList('h') &lt;&lt; endl; cout &lt;&lt; \"search_pos = \" &lt;&lt; p-&gt;SearchList('i') &lt;&lt; endl; delete p; return 0;&#125; 运行结果 代码未经过严谨测试,如果有错,欢迎大家指正和交流啊.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-线性表|顺序表|链表(中)","slug":"数据结构-线性表-顺序表-链表-中","date":"2018-02-18T05:19:16.000Z","updated":"2018-05-05T15:04:59.188Z","comments":true,"path":"2018/02/18/数据结构-线性表-顺序表-链表-中/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-线性表-顺序表-链表-中/","excerpt":"数据结构-线性表|顺序表|链表(中)本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list)","text":"数据结构-线性表|顺序表|链表(中)本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list) 03 单链表(Singly Linked List )3.1 什么是单链表？单链表是一种链式存储的结构。它动态的为节点分配存储单元。当有节点插入时，系统动态的为结点分配空间。在结点删除时，应该及时释放相应的存储单元，以防止内存泄露。由于是链式存储，所以操作单链表时，必须知道头结点或者头指针的位置。并且，在查找第i个节点时，必须找到第i-1个节点。 3.2 单链表的存储结构代码描述对于链式存储，通过上一节的讲解相信大家已经了解得够清楚了。如下图所示： 下面我们来看看单链表存储是如何用代码来实现的。123456//单链表的存储结构C语言代码typedef struct SListNode&#123; datatype data; //数据域 struct SListNode * pnext;//指针域&#125;SLinkList; 由上面的结构我们可以看出，一个节点由存放数据的数据域和存放地址的指针域组成。假如p指向了第i个节点，那么p-&gt;data就是该节点存放的数据，而p-&gt;pnext自然就是指向下一个节点的指针。如下图所示： 那么接下来我们看看单链表的各个操作具体实现吧。(只讲几个关键步骤)备注：下面的代码基于这样的一个单链表： 有一个头指针phead 有一个头结点node 头指针指向头结点，头结点位置记为03.3 单链表的读取在拿到头指针以后，单链表的读取也并非一件难事。一开始设置一个计数变量，不断遍历链表，让计数器自增。找到合适的位置将数据读取出来。具体代码实现如下：12345678910111213141516171819202122232425262728#define status bool#define ERROR false#define OK true/* * 函数功能：获取位置index节点的数据 * 参数说明：phead链表头结点，e用来获取的变量，index索引*/status GetSListIndexNode(Node * phead,DType *e, int index)&#123; int icount = 0; //计数器 //注：0号位为头结点，头结点不存放任何数据 if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()/*此处为链表长度*/) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; icount++; phead = phead-&gt;pnext; if (icount == index) &#123; *e = phead-&gt;data; return OK; &#125; &#125; return ERROR;&#125; 3.4 单链表的插入3.4.1 指定位置后插其实链表的插入和删除都是很简单的操作，初学者只要抓住指针指向的节点，并加以区分开来，就很easy了。如下图： 图中，假如此时p指向了我们要插入的节点的位置。那么，怎样把我们的S节点给插入到p指向的节点之后？在这里我们先不要惊动p以及p后面的节点： 我们先让S节点指向p之后的节点(步骤①) 之后我们切断p和p后面那个节点的关系(步骤②) 最后让p节点的指针域指向s节点(步骤③)，搞定 算法描述： 声明一个指针p指向链表头结点，向后遍历p=p-&gt;next，找到正确的位置。 新建一个结点s。 s-&gt;next = p-&gt;next ① p-&gt;next = s ②③具体代码如下：12345678910111213141516171819202122232425262728293031#define status bool#define ERROR false#define OK true/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData插入的数据，index索引*/status InsertSListNodeFront(Node * phead, DType IData, int index)&#123; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if ( iCount == index ) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125; 3.4.1 指定位置前插咳咳，聪明的小伙伴，用脑子想想。指定位置前插 == 指定位置的前一个位置进行后插。懂了吧？直接看具体代码：123456789101112131415161718192021222324252627282930/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData插入的数据，index索引*/status InsertSListNodeBack(Node * phead, DType IData, int index)&#123; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = phead; phead = phead-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125; 3.5 单链表的删除单链表的删除其实也是很简单。只要比如要删除p指向的节点，只需要让p之前的节点的指针域直接指向p之后的节点，再把p给free就OK了。如下图： 算法描述: 声明一个指针p指向链表头结点，向后遍历p=p-&gt;next，找到要删除的节点位置。 q = p-&gt;next p-&gt;next = q-&gt;next ①② free(q) ③④ 具体代码如下:12345678910111213141516171819202122232425262728/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData获取删除的数据，index索引*///删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status DeleteSListIndexNode(Node * phead, DType *e, int index)&#123; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; q = phead; //保存备用 phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; q-&gt;pnext = phead-&gt;pnext; //删除出局 return OK; &#125; &#125; return ERROR;&#125; 代码应该不难，相信大家都能很容易看懂。 3.6 单链表的完整代码好了，前面介绍了几个重要的操作，接下来请大家看看完整的代码吧。小编为了使用方便，就用C++的class和template将整个链表封装到了一个类里面，通过模板实现泛型编程。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415/* * 文件名:SingleLinkList.h * 说明 ：类的各种声明 */#pragma once //VC编译器防止头文件被重复包含的一条预编译指令#define status bool#define OK true#define ERROR false#define YES true#define NO falsetemplate &lt;typename DType&gt;class Node&#123;public: DType data; Node * pnext;&#125;;template &lt;typename DType&gt;class CSingleLinkList&#123;private: Node&lt;DType&gt; *phead; //链表头指针public: CSingleLinkList();//构造，类被创建时调用 ~CSingleLinkList();//析构，类被销毁时调用public: //初始化链表 status InitSList(); //获取链表长度 int GetSListLength(); //增加一个节点 前插法 status AddSListNodeFront(DType idata); //增加一个节点 后插法 status AddSListNodeBack( DType idata); //判断链表是否为空 status IsSListEmpty(); //获取指定位置节点值(注意，本程序规定0号为头节点，e获取删除元素) status GetSListIndexNode(DType *e, int index); //删除指定位置节点(e获取删除元素) status DeleteSListIndexNode(DType *e, int index); //查找链表中指定值(pindex获取位置0==&gt;not found) status SearchSListNode(DType SData, int *pindex); //指定位置前插 status InsertSListNodeFront(DType IData, int index); //指定位置后插 status InsertSListNodeBack(DType IData, int index); //清空链表(保留根节点) status ClearSList(); //销毁链表(all delete) status DestorySList(); //尾部删除一个元素 status DeleteSListNodeBack(); //打印链表 此函数根据实际情况而定 void PrintSList();&#125;;/* * 文件名:SingleLinkList.cpp * 说明 ：类的各种方法的实现 */#include \"SingleLinkList.h\"#include &lt;stdio.h&gt;template &lt;typename DType&gt;CSingleLinkList&lt;DType&gt;::CSingleLinkList()&#123; cout &lt;&lt; \"链表创建\" &lt;&lt; endl; InitSList();&#125;template &lt;typename DType&gt;CSingleLinkList&lt;DType&gt;::~CSingleLinkList()&#123; cout &lt;&lt; \"链表销毁\" &lt;&lt; endl; DestorySList();&#125;//初始化链表template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InitSList()&#123; Node&lt;DType&gt; * ph = new Node&lt;DType&gt;; if (ph != NULL) &#123; ph-&gt;pnext = nullptr; this-&gt;phead = ph; //头结点 return OK; &#125; return ERROR;&#125;//获取链表长度(head_node is not included)template &lt;typename DType&gt;int CSingleLinkList&lt;DType&gt;::GetSListLength()&#123; int length = 0; Node&lt;DType&gt; * phead = this-&gt;phead; while (phead-&gt;pnext != nullptr) &#123; length++; phead = phead-&gt;pnext; &#125; return length;&#125;//增加一个节点 前插法template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::AddSListNodeFront( DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; if (pnode != NULL) &#123; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead-&gt;pnext; this-&gt;phead-&gt;pnext = pnode; //挂载 //printf(\"pnode = %p pnode-&gt;pnext = %p this-&gt;phead-&gt;pnext = %p this-&gt;phead = %p\\n\", pnode, pnode-&gt;pnext, this-&gt;phead-&gt;pnext, this-&gt;phead); return OK; &#125; return ERROR;&#125;//增加一个节点 尾插法template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::AddSListNodeBack(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; Node&lt;DType&gt; * phead = this-&gt;phead; if (pnode != NULL) &#123; while (phead-&gt;pnext != nullptr) &#123; phead = phead-&gt;pnext; &#125; pnode-&gt;data = idata; pnode-&gt;pnext = nullptr; phead-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//判断链表是否为空template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::IsSListEmpty()&#123; if (this-&gt;phead-&gt;pnext == nullptr) &#123; return YES; &#125; return NO;&#125;//获取指定位置节点值(注意，本程序规定0号为头节点，e获取节点的值)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::GetSListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int i = 0; //计数器 if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; return OK; &#125; &#125; return ERROR;&#125;//删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DeleteSListIndexNode( DType *e, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; q = phead; //保存备用 phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; q-&gt;pnext = phead-&gt;pnext; //删除出局 return OK; &#125; &#125; return ERROR;&#125;//查找链表中指定值(pindex获取位置 0==&gt;not found)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::SearchSListNode( DType SData, int *pindex)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int iCount = 0;//计数器 while (phead-&gt;pnext != nullptr) &#123; iCount++; phead = phead-&gt;pnext; if (phead-&gt;data == SData) &#123; *pindex = iCount; return YES; &#125; &#125; *pindex = 0; return NO;&#125;//指定位置前插template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InsertSListNodeFront(DType IData, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if ( iCount == index ) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125;//指定位置后插template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InsertSListNodeBack( DType IData, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = phead; phead = phead-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125;//清空链表(保留根节点)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::ClearSList()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //防止那啥，野指针 phead = phead-&gt;pnext;//保留头节点 while (phead != nullptr) &#123; q = phead; phead = phead-&gt;pnext; delete q; //释放 &#125; this-&gt;phead-&gt;pnext = nullptr; return OK;&#125;//销毁链表(all delete)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DestorySList()&#123; ClearSList(); delete this-&gt;phead;//释放头结点 return OK;&#125;template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DeleteSListNodeBack()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //备用 if (phead-&gt;pnext == nullptr) &#123; return ERROR; //链表都空了还删鸡毛 &#125; while (phead-&gt;pnext != nullptr) &#123; q = phead; phead = phead-&gt;pnext; &#125; q-&gt;pnext = nullptr; delete phead; return OK; &#125;template &lt;typename DType&gt;void CSingleLinkList&lt;DType&gt;::PrintSList()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || phead == nullptr) &#123; cout &lt;&lt; \"链表为空，打印鸡毛\" &lt;&lt; endl; return; &#125; int i = 1; cout &lt;&lt; \"===============print list================\" &lt;&lt; endl; while (phead-&gt;pnext != nullptr) &#123; phead = phead-&gt;pnext; cout &lt;&lt;\"node[\" &lt;&lt; i++ &lt;&lt; \"] = \" &lt;&lt; phead-&gt;data&lt;&lt;endl; &#125;&#125;/* * 文件名:SingleLinkListTest.cpp * 说明 ：测试代码 */ #include &lt;iostream&gt;#include \"SingleLinkList.h\"#include \"SingleLinkList.cpp\"using namespace std;int main()&#123; CSingleLinkList&lt;int&gt; * pMySList = new CSingleLinkList&lt;int&gt;; cout &lt;&lt; pMySList-&gt;IsSListEmpty() &lt;&lt; endl; pMySList-&gt;AddSListNodeFront(111); pMySList-&gt;AddSListNodeFront(222); pMySList-&gt;AddSListNodeFront(333); cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetSListLength() &lt;&lt; endl; pMySList-&gt;PrintSList(); pMySList-&gt;AddSListNodeBack(444); pMySList-&gt;AddSListNodeBack(555); pMySList-&gt;AddSListNodeBack(666); pMySList-&gt;PrintSList(); cout &lt;&lt; pMySList-&gt;IsSListEmpty() &lt;&lt; endl; cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetSListLength() &lt;&lt; endl; int GetElem, GetIndex; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 2); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 6); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 4); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteSListIndexNode(&amp;GetElem, 1); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteSListIndexNode(&amp;GetElem, 3); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;PrintSList(); pMySList-&gt;SearchSListNode(555, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchSListNode(111, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchSListNode(666, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;InsertSListNodeFront(333, 1); pMySList-&gt;InsertSListNodeFront(444, 4); pMySList-&gt;PrintSList(); pMySList-&gt;InsertSListNodeBack(777, 3); pMySList-&gt;InsertSListNodeBack(888, 5); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); return 0;&#125;代码如果有不正确的地方，欢迎大家来指正哈。 04 静态链表(circular linked list)4.1 什么是静态链表？我们把线性表的元素存放在数组中，这些元素由两个域组成： 数据域data 指针域cur 数据域是存放数据的，而指针域，这里和链表不同是，它存的不再是指向下一个节点的内存地址。而是下一个节点在数组中的下标。我们就把这种用数组描述的链表称为静态表，该方法也称之为游标实现法。如下图所示： 由上图我们需要注意以下几点： 我们对数组的第一个元素和最后一个元素做特殊处理，不存放数据。 把未使用的数组元素称为备用链表。 数组的第一个元素(下标为0)的cur域存放备用链表第一个节点的下标。 数组的最后一个元素的cur域存放第一个有数据的节点的下标，相当于链表中头结点的存在。链表为空时，其值为0。 如下图： 引出的问题：数组的长度定义的问题，无法预支。所以，为了防止溢出，我们一般将静态表开得大一点。 4.2 静态链表存储的代码描述基于上面的讲解，我们来看看代码是怎么描述这种存储结构的。1234567//---------线性表的静态单链表存储结构--------#define MAXSIZE 1000 /*假设链表最大长度为1000*/typedef struct&#123; datatype data; int cur; //为0时表示无指向&#125;SLinkList[MAXSIZE]; 接下来我们讲解几个重要的操作实现。 4.3 静态链表的插入操作前面我们讲动态链表的时候说过，增加和删除一个节点我们可以用malloc()和free()函数(C++可用new和delete)来实现。但是现在由于我们操作的是静态表，它可是用数组存的，可没有这种操作了。因此我们首先来自己实现一个静态表的malloc和free。 那么怎么辨别数组中哪些空间没有被使用呢？一个好的解决办法是，将所有未使用或者被删除的空间串成一个备用链表。插入节点时便可以从备用链表获取第一个未使用的空间的下标。因此我们在初始化的时候会做这样的工作： 12345678910void SListInit(SLinkList space)&#123; int i; for(i = 0; i &lt; MAXSIZE; i++) space[i].cur = i+1; //将所有结点链入备用链表 //备用链表头指针链像第二个结点 space[0].cur = space[1].cur; //第一个结点作为链表的头结点 space[1].cur = 0; &#125; 分配内存123456789101112/分配备用链表的一个结点,返回下标//若为0，则说明备用链表用完int Malloc_SL(SLinkList space)&#123; int i = space[0].cur; //判断备用链表是否非空 if(space[0].cur) //备用链表头指针指向第二个空结点 space[0].cur = space[i].cur; return i; //返回第一个空结点&#125; 上面的代码应该是没有难度的。写完了这个函数，我们来看看静态表中具体如何插入：12345678910111213141516171819//在链表的第i个位置插入元素evoid SlistInsert(SLinkList space, int i, ElemType e)&#123; //超出范围 if(i &lt; 1 || i &gt; SListLength(space)+1) return; int k = 1, j; //使k指示要插入的结点的前一个结点 for(j = 0; j &lt;i-1; j++) k = space[k].cur; int v = Malloc_SL(space); if(v) //如果有空间 &#123; space[v].data = e; space[v].cur = space[k].cur; space[k].cur = v; //链入链表 &#125;&#125; 注意几点： 首先我们让k指向了要插入节点(记为X)的前一个位置(记为Y节点)，前插法。 然后我们在静态表内申请空间，存放新的节点(记为N)。 把数据放进新申请的节点里面。 新节点N的cur域指向X节点，然后让Y节点指向N节点。 该过程不难理解。就不上图了…… 4.4 静态链表的删除操作删除同样需要自己实现free函数，我们来看看代码： 回收内存12345678//将下标为k的空闲结点回收到备用链表void Free_SL(SLinkList space, int k)&#123; //将备用链表链到k之后 space[k].cur = space[0].cur; //将k链到备用链表头之后 space[0].cur = k; &#125; 删除以后记得把空间重新挂载到备用链表上以便下一次使用。下面我们实现删除的代码： 1234567891011121314//删除第i个位置的元素void SListDelete(SLinkList space, int i)&#123; //超出范围退出 if(i &lt; 1 || i &gt; SListLength(space)) return ; int k = 1, j; //使k指示要删除的结点的前一个结点 for(j = 0; j &lt;i-1; j++) k = space[k].cur; int temp = space[k].cur; space[k].cur = space[temp].cur; Free_SL(space, temp);&#125; 其实代码也很好理解了。假如X、Y、Z……等等排列，我们要删除Y。无非就是告诉X，你不要指向Y了，你直接指向Z，然后我们再把Y给free了。就直接变成了X、Z……简单吧。 4.5 静态链表的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/************************************* 静态链表数据结构：每个数组节点都有值和游标.游标表示下一个节点，节点分为已用节点和备用节点第一个节点和最后节点保留：第一个节点游标表示备用节点起始位置最后一个节点游标表示已用节点的起始位置已用节点的最后一个元素的游标指向0，表示末尾。*************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define ERROR 0#define OK 1#define MAX 100 //声明数组的最大长度typedef int Status,ElemType;typedef struct&#123; int data; //数据 int cur; //游标&#125;component,staticlink[MAX]; //定义结构体数组/********************************** 初始化链表输入值：链表的指针输出值：状态码功能： 将所以节点的游标指向后一个节点 ***********************************/Status initLink(staticlink space)&#123; int i; for(i=0;i&lt;(MAX-1);i++)&#123; //遍历所有节点 space[i].cur = i+1; //将节点的游标指向下个节点 &#125; space[MAX-1].cur = 0; //最后一个节点的游标指向第一个节点 return OK;&#125;/********************************* 分配备用空间输入值：链表的指针输出值：备用节点的下标功能： 将备用节点的分配出来使用 *********************************/int mallocSpace(staticlink space)&#123; int i; i = space[0].cur; //取出第一个备用节点 if(space[0].cur) //如果取出成功 space[0].cur = space[i].cur; //第一个节点的指针往后移动 return i;&#125;/******************************** 获取长度输入值：链表的指针输出值：长度值功能： 将链表中已用的节点个数返回 ********************************/int getLength(staticlink space)&#123; int mov = MAX-1; int j=0; while(space[mov].cur) &#123; //遍历所有已用节点 mov = space[mov].cur; j++; &#125; return j;&#125;/********************************* 创建值输入值：链表的指针，初始值个数输出值：状态码功能： 为链表初始指定个数的随机值 *********************************/Status createValue(staticlink space,int num)&#123; srand(time(0)); int i,mov = MAX-1; space[mov].cur = 1; for(i=0;i&lt;num;i++) &#123; mov = space[mov].cur; //移动游标 space[mov].data = rand()%100+1; //初始化随机值 &#125; space[0].cur = space[mov].cur;//第一节点游标指向备用节点 space[mov].cur = 0; //最后一个已用节点指向第一个节点 return OK;&#125;/********************************* 插入节点输入值：链表的指针，插入位置(从1开始)，插入位置输出值：状态码功能： 在指定的位置插入指定的值 *********************************/Status insertNode(staticlink space,int index,ElemType e)&#123; int new,mov,i; if(index&lt;1 || index&gt;getLength(space))return ERROR; //不可以超过已用节点个数 mov = MAX-1; new = mallocSpace(space); if(new)&#123; space[new].data=e; //创建新节点 for(i=1;i&lt;index;i++)//定位插入节点的前一节点 mov = space[mov].cur; space[new].cur = space[mov].cur; //连后 space[mov].cur = new; //接前 return OK; &#125; return ERROR;&#125;/************************************ 删除节点输入值：链表的指针，删除位置(从1开始)输出值：状态码功能： 删除指定的节点 ************************************/Status deleteNode(staticlink space,int index)&#123; if(index&lt;1 || index&gt;getLength(space))return ERROR; int mov,next,i; mov = MAX-1; for(i=1;i&lt;index;i++) //定位删除节点的前一节点 mov = space[mov].cur; next = space[mov].cur;//获取被删节点 space[mov].cur = space[next].cur; //前一节点连接被删节点的游标 freeNode(space,next);//释放被删节点 return OK;&#125;/*********************************** 释放节点输入值：链表的指针，释放节点的位置输出值：状态码功能: 将已用节点释放成备用节点 ***********************************/Status freeNode(staticlink space,int target)&#123; space[target].cur = space[0].cur;//释放节点连接第一备用节点 space[0].cur = target;//第一节点连接释放节点 return OK;&#125;/********************************** 输出链表输入值：链表的指针输出值：状态码功能： 将链表的值一一输出 **********************************/Status printLink(staticlink space)&#123; int mov = MAX-1; while(space[mov].cur) &#123; mov = space[mov].cur; printf(\"[%d] \",space[mov].data); &#125; printf(\"\\n\"); return OK;&#125;int main()&#123; int num,value,index; staticlink L; initLink(L); printf(\"[create]enter num:\"); scanf(\"%d\",&amp;num); createValue(L,num); printLink(L); printf(\"[insert]enter index:\"); scanf(\"%d\",&amp;index); printf(\"[insert]enter value:\"); scanf(\"%d\",&amp;value); insertNode(L,index,value); printLink(L); printf(\"[delete]enter index:\"); scanf(\"%d\",&amp;index); deleteNode(L,index); printLink(L); return 0; 这次就先到这里吧。更多精彩内容，请期待下回分解。 另外：部分资料参考自网络，来源和作者实在无法考证，如果有侵犯到您的劳动成果，请速与我联系。 ========================END=======================","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-线性表|顺序表|链表(上)","slug":"数据结构-线性表-顺序表-链表-上","date":"2018-02-18T05:14:40.000Z","updated":"2018-05-05T15:05:58.879Z","comments":true,"path":"2018/02/18/数据结构-线性表-顺序表-链表-上/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-线性表-顺序表-链表-上/","excerpt":"本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list)","text":"本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list) 01 预备知识1.0 什么是线性表?线性表(List)是零个或者多个数据元素的有限序列. 首先它是一个序列.里面的元素是有顺序的,如果有多个元素,除开头和结尾以外的元素都有一个前驱和一个后继.而开头元素只有后继,结尾元素只有前驱. 其次线性表是有限的，也就是里面的元素个数是有限的。 1.1 线性表的基本操作(描述)12345678910111213ADT 线性表（List）Data 线性表的数据对象集合为&#123;a1, a2, a3, ......, an&#125;,每个元素类型为DataType。Operation InitList(L); //初始化线性表 IsEmptyList(L); //判断线性表是否为空 ClearList(L); //清空线性表 GetElemList(L, i, *e); //获取第i个位置的数据 SearchList(L, e); //查找与数据e相等的元素 InsertNodeList(L, i, e);//在第i个位置插入元素 DeleteNodeList(L, i, *e);//删除第i个位置的元素，e获取删除元素 GetLengthList(L); //获取线性表的长度endADT 关于线性表的基本操作就上面几种，还有几个例如线性表的排序，合并，逆序等等操作。为了文章篇幅，就下次再介绍了。 1.2 什么是顺序存储结构?线性表的顺序存储结构，就是指 用一段地址连续的存储单元一次存储线性表的数据元素。学过高级语言的朋友，相信对数组这玩意儿都不会陌生吧。数组就是一种顺序存储结构。 1.3 什么是链式存储结构?链式存储结构就是可以用一组任意的内存单元存储线性表中的元素。与顺序存储不同的是，这组内存单元可以是连续的，也可以是不连续的。这就意味着，元素可以存储在内存的任意位置。正因为如此，在链式结构中，每个元素不仅要存它的信息，还需要存储它后继元素的存储地址。我们把存储元素信息的域称为数据域，而把存储后继元素地址的域称为指针域。由这两部分共同组成的数据元素ai，则可以称之为节点(Node)。如下面这个图所示： 1.5 什么是链表?链表就是链式存储的线性表。结点之间通过逻辑连接，形成链式存储结构。存储结点的内存单元，可以是连续的也可以是不连续的。逻辑连接与物理存储次序没有关系。 02 顺序表(Sequential List)2.0 什么是顺序表? 采用顺序存储结构的线性表，就是顺序表。 2.1 顺序表的存储结构代码这里我们统一采用C语言来描述。1234567#define MAXSIZE 20 //存储空间的初始大小typedef int DataType //类型可根据实际情况而定typedef struct &#123; DataType data[MAXSIZE]; //数组来存储数据 int length; //实际长度&#125;SqlList; 可见，顺序表的几个重要特性： 存储空间的位置：数组data 顺序表的最大容量：数组长度MAXSIZE 顺序表当前长度：length 2.2 顺序表的插入操作相信大家在排队的时候都有过被插队的体验吧。当一个插队到你前面时，这个时候你内心os mmp外加素质三连的同时，也不得不往后挪一个位置。于是乎这个就不得了了，你后面的也要往后挪，你后面的后面也是……然后队伍里瞬间就狼烟起……那么，这个顺序表的插入其实也差不多的。由于地址是连续存储的，那么在某个地方插入以后，其后的元素不得不往后挪一个位置。 插入算法描述： 异常处理(插入位置不合理、顺序表已经满等等)。抛出异常。 从最后一个元素往前遍历到第i个位置，依次将他们都往后挪一个位置。 将要插入的元素放入位置i处。 别忘记了表长度length++。 由于数组下标是从0开始的，我们习惯要删除的位置第i处又是从1开始算起的。本文就全部统一成，都从0开始吧。比如要在第5个位置插入一个元素，那就是a[5]。不然真的会混乱的。 具体代码如下：1234567891011121314151617//功能：在顺序表L第i个位置之前插入元素eint InsertSqlList(SqlList *L, int i, DataType data)&#123; int k; if(L-&gt;length==MAXSIZE || i&lt;0 || i&gt;L-&gt;length) //记住，都是从0开始的哦 return 0;//异常处理 if(i == L-&gt;length) L-&gt;data[length++] = data;//尾插一步到位 if(i &lt; L-&gt;length) //中间插，要挪人啦 &#123; for(k = L-&gt;length-1; k &gt;= i;k--) //再次强调哈，都是从0开始的。 L-&gt;data[k+1]=L-&gt;data[k];//后移 L-&gt;data[i] = data;//新元素插入 L-&gt;length++; &#125; return 1;&#125; 2.2 顺序表的删除操作算法描述： 异常处理(删除位置不合理、顺序表为空等等) 尾删，直接获取然后length–。 中间删，从i开始往后遍历，依次将各元素往前挪。e获取要删元素，length–即可。12345678910111213141516171819//功能：在顺序表L中删除第i个数据元素，用e获取被删除值int DeleteElemList(SqlList *L, int i, DataType *e)&#123; int k; if(L-&gt;length==0 || i&lt;0 || i&gt;L-&gt;length-1) //记住，都是从0开始的哦 return 0;//异常处理 if(i == L-&gt;length-1) //尾删，easy &#123; *e = L-&gt;data[i];//获取要删除元素 L-&gt;length--; //删除元素 &#125; if(i &lt; L-&gt;length) //中间删，要挪人啦 &#123; *e = L-&gt;data[i];//获取要删除元素 for(k = i; k &lt; L-&gt;length-1;k++) //再次强调哈，都是从0开始的。 L-&gt;data[k]=L-&gt;data[k+1];//前移 L-&gt;length--; return 1; &#125; 2.3 顺序表的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 20#define ERROR 0#define OK 1#define NO 0#define YES 1typedef int DataType;typedef int Status;typedef struct List&#123; int data[MAXSIZE]; int length;&#125;SqlList;void InitList(SqlList * L); //初始化顺序表Status IsEmptyList(SqlList *L); //判断顺序表是否为空void ClearList(SqlList *L); //清空线性表Status GetElemList(SqlList *L,int i,DataType *e); //获取第i个位置的数据int SearchList(SqlList *L, DataType e); //查找与数据e相等的元素Status InsertNodeList(SqlList *L, int i,DataType e);//在第i个位置插入元素Status DeleteNodeList(SqlList *L, int i, DataType *e);//删除第i个位置的元素，e获取删除元素int GetLengthList(SqlList *L); //获取线性表的长度void PrintList(SqlList *L); //遍历顺序表,此函数测试使用，根据实际类型编写int main()&#123; int e; SqlList *pL = (SqlList*)malloc(sizeof(SqlList)); InitList(pL); InsertNodeList(pL, 0, 1); InsertNodeList(pL, 1, 2); InsertNodeList(pL, 2, 3); InsertNodeList(pL, 3, 4); InsertNodeList(pL, 4, 5); InsertNodeList(pL, 5, 6); PrintList(pL); DeleteNodeList(pL, 2, &amp;e); DeleteNodeList(pL, 4, &amp;e); PrintList(pL); return 0;&#125;void InitList(SqlList * L)&#123; for(int i = 0; i &lt; MAXSIZE; i++) L-&gt;data[i] = 0; L-&gt;length = 0; //将表设为空&#125;Status IsEmptyList(SqlList *L)&#123; if(L-&gt;length == 0) return YES;//表为空 else return NO;&#125;void ClearList(SqlList *L)&#123; InitList(L);//此操作跟初始化一样。&#125;//这里的第i个位置，为了统一我们也是从0算起的Status GetElemList(SqlList *L,int i,DataType *e)&#123; if(i &lt; 0 || i &gt;= L-&gt;length || L-&gt;length == 0) return ERROR;//异常处理 *e = L-&gt;data[i]; return OK;&#125;//找到与数据e相同的节点，返回下标。-1表示没找到,ERROR表示表为空int SearchList(SqlList *L, DataType e)&#123; if(L-&gt;length == 0) return ERROR; for(int i = 0; i &lt; L-&gt;length; i++) &#123; if(L-&gt;data[i] == e) return i; &#125; return -1;&#125;//获取顺序表的长度int GetLengthList(SqlList *L)&#123; return L-&gt;length;&#125;//在位置i插入元素，再次强调，从0开始Status InsertNodeList(SqlList *L, int i,DataType e)&#123; if(i &lt; 0 || i &gt; L-&gt;length || L-&gt;length == MAXSIZE) return ERROR;//异常处理 for(int k = L-&gt;length; k &gt; i; k--) &#123; L-&gt;data[k] = L-&gt;data[k-1]; //往后挪 &#125; L-&gt;data[i] = e;//插入数据， L-&gt;length++; //长度也要加1 return OK;&#125;Status DeleteNodeList(SqlList *L, int i, DataType *e)&#123; if(i &lt; 0 || i &gt; L-&gt;length || L-&gt;length == 0) return ERROR;//异常处理 *e = L-&gt;data[i];//获取数据 for(int k = i; k &lt; L-&gt;length -1; k++) L-&gt;data[k] = L-&gt;data[k+1];//往前挪 L-&gt;length--; //长度减1 return OK;&#125;void PrintList(SqlList *L)&#123; if(L-&gt;length == 0) &#123; printf(\"顺序表为空\\n\"); &#125; printf(\"============遍历顺序表如下=============\\n\"); for(int i = 0; i &lt; L-&gt;length; i++) &#123; printf(\"\\tdata[%d] = %d\\n\", i, L-&gt;data[i]); &#125; printf(\"============共计%d个元素=============\\n\", L-&gt;length);&#125; 纯手打哈。。简单测试了一下。如果存在问题，欢迎指正，谢谢大家。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]}]}