{"meta":{"title":"无限Coding","subtitle":null,"description":null,"author":"infinitor","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"用回溯法(backtracking algorithm)求解N皇后问题(N-Queens puzzle)","slug":"用回溯法-backtracking-algorithm-求解N皇后问题-N-Queens-puzzle","date":"2018-02-18T05:26:19.000Z","updated":"2018-02-18T05:26:58.891Z","comments":true,"path":"2018/02/18/用回溯法-backtracking-algorithm-求解N皇后问题-N-Queens-puzzle/","link":"","permalink":"http://yoursite.com/2018/02/18/用回溯法-backtracking-algorithm-求解N皇后问题-N-Queens-puzzle/","excerpt":"","text":"什么是N-皇后问题?说到这个N-皇后问题，就不得不先提一下这个历史上著名的8皇后问题啦。 八皇后问题，是一个古老而著名的问题.该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法? 那么，我们将8皇后问题推广一下，就可以得到我们的N皇后问题了。N皇后问题是一个经典的问题，在一个NxN的棋盘上放置N个皇后，使其不能互相攻击 (同一行、同一列、同一斜线上的皇后都会自动攻击) 那么问，有多少种摆法？ 回溯算法(backtracking algorithm)N皇后问题其实就是回溯算法中的一个典型应用。为此，在这里先介绍一下回溯算法。 定义(参考至百度百科) 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 基本思想 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 什么是深度优先搜索？ 深度优先搜索(DFS即Depth First Search)其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 解决问题的一般步骤 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。 确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。 解空间和解空间树 解空间一个复杂问题的解决往往由多部分构成，那么，一个大的解决方案就可以看成是由若干个小的决策组成。很多时候它们构成一个决策序列。解决一个问题的所有可能的决策序列构成该问题的解空间。解空间中满足约束条件的决策序列称为可行解。一般说来，解任何问题都有一个目标，在约束条件下使目标值达到最大（或最小）的可行解称为该问题的最优解。在解空间中，前k项决策已经取定的所有决策序列之集，称为k定子解空间。0定子解空间即是该问题的解空间。这个空间必须至少包含一个解（可能是最优的）。 解空间树因为回溯方法的基本思想是通过搜索解空间来找到问题所要求的解，所以如何组织解空间的结构会直接影响对问题的求解效率。一般地，我们可以用一棵树来描述解空间，并称之为解空间树。 算法框架 针对N叉树的递归回溯方法 123456789101112131415161718//针对N叉树的递归回溯方法 void backtrack (int t)&#123; if (t&gt;n) &#123; output(x); //叶子节点，输出结果，x是可行解 &#125; else &#123; for i = 1 to k//当前节点的所有子节点 &#123; x[t]=value(i); //每个子节点的值赋值给x //满足约束条件和限界条件 if (constraint(t)&amp;&amp;bound(t)) backtrack(t+1); //递归下一层 &#125; &#125;&#125; 针对N叉树的迭代回溯方法 12345678910111213141516171819202122232425//针对N叉树的迭代回溯方法void iterativeBacktrack () &#123; int t=1; while (t&gt;0) &#123; if(ExistSubNode(t)) //当前节点的存在子节点 &#123; for i = 1 to k //遍历当前节点的所有子节点 &#123; x[t]=value(i);//每个子节点的值赋值给x if (constraint(t)&amp;&amp;bound(t))//满足约束条件和限界条件 &#123; //solution表示在节点t处得到了一个解 if (solution(t)) output(x);//得到问题的一个可行解，输出 else t++;//没有得到解，继续向下搜索 &#125; &#125; &#125; else //不存在子节点，返回上一层 t--; &#125; &#125; N皇后问题的solve算法伪代码描述下面是算法的高级伪码描述，这里用一个N*N的矩阵来存储棋盘： 1) 算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列 2) 在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第4步 3) 在当前位置上满足条件的情形： 在当前位置放一个皇后，若当前行是最后一行，记录一个解； 若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置； 若当前行是最后一行，当前列不是最后一列，当前列设为下一列； 若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置。 以上返回到第2步 4) 在当前位置上不满足条件的情形： 若当前列不是最后一列，当前列设为下一列，返回到第2步; 若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步; 图解问题过程为了让大家更好理解，这里画了一张图。 coding time我们之前说过N皇后问题是回溯算法的经典应用。因此我们可以使用回溯法来解决该问题，具体实现也有两个途径，递归和非递归。 递归法其实递归法算是比较简单的了。我们使用一个一维数组来存储棋盘。具体细节如下：把棋盘存储为一个一维数组a[N]，数组中第i个元素的值代表第i行的皇后位置。在判断是否冲突时也很简单： 首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了。 其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。 至于斜线冲突，通过观察可以发现所有在斜线上冲突的皇后的位置都有规律。即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const int N=20; //最多放皇后的个数int q[N]; //i表示皇后所在的行号， //q[i]表示皇后所在的列号int cont = 0; //统计解的个数//输出一个解void print(int n)&#123; int i,j; cont++; printf(\"第%d个解：\",cont); for(i=1;i&lt;=n;i++) printf(\"(%d,%d) \",i,q[i]); printf(\"\\n\"); for(i=1;i&lt;=n;i++) //行 &#123; for(j=1;j&lt;=n;j++) //列 &#123; if(q[i]!=j) printf(\"x \"); else printf(\"Q \"); &#125; printf(\"\\n\"); &#125;&#125;//检验第i行的k列上是否可以摆放皇后int find(int i,int k)&#123; int j=1; while(j&lt;i) //j=1~i-1是已经放置了皇后的行 &#123; //第j行的皇后是否在k列或(j,q[j])与(i,k)是否在斜线上 if(q[j]==k || abs(j-i)==abs(q[j]-k)) return 0; j++; &#125; return 1;&#125;//放置皇后到棋盘上void place(int k,int n)&#123; int j; if(k&gt;n) print(n); //递归出口 else &#123; for(j=1;j&lt;=n;j++) //试探第k行的每一个列 &#123; if(find(k,j)) &#123; q[k] = j; //保存位置 place(k+1,n); //接着下一行 &#125; &#125; &#125;&#125;int main1111(void)&#123; int n; printf(\"请输入皇后的个数(n&lt;=20),n=:\"); scanf(\"%d\",&amp;n); if(n&gt;20) printf(\"n值太大，不能求解!\\n\"); else &#123; printf(\"%d皇后问题求解如下(每列的皇后所在的行数):\\n\",n); place(1,n); //问题从最初状态解起 printf(\"\\n\"); &#125; system(\"pause\"); return 0;&#125; 迭代法为什么还要迭代呢？因为递归效率有时候并不是那么的高。具体思路：首先对N行中的每一行进行探测，查找该行中可以放皇后的位置。具体怎么做呢？ 首先对该行的逐列进行探测，看是否可以放置皇后，如果可以，则在该列放置一个皇后，然后继续探测下一行的皇后位置。 如果已经探测完所有的列都没有找到可以放置皇后的列，这时候就应该回溯了，把上一行皇后的位置往后移一列。 如果上一行皇后移动后也找不到位置，则继续回溯直至某一行找到皇后的位置或回溯到第一行，如果第一行皇后也无法找到可以放置皇后的位置，则说明已经找到所有的解，程序终止。 如果该行已经是最后一行，则探测完该行后，如果找到放置皇后的位置，则说明找到一个结果，打印出来。 但是此时并不能在此处结束程序，因为我们要找的是所有N皇后问题所有的解，此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。 由此可见，非递归方法的一个重要问题时何时回溯及如何回溯的问题。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define QUEEN 8 //皇后的数目#define INITIAL -10000 //棋盘的初始值int a[QUEEN]; //一维数组表示棋盘void init() //对棋盘进行初始化&#123; int *p; for (p = a; p &lt; a + QUEEN; ++p) &#123; *p = INITIAL; &#125;&#125;int valid(int row, int col) //判断第row行第col列是否可以放置皇后&#123; int i; for (i = 0; i &lt; QUEEN; ++i) //对棋盘进行扫描 &#123; //判断列冲突与斜线上的冲突 if (a[i] == col || abs(i - row) == abs(a[i] - col)) return 0; &#125; return 1;&#125;void print() //打印输出N皇后的一组解&#123; int i, j; for (i = 0; i &lt; QUEEN; ++i) &#123; for (j = 0; j &lt; QUEEN; ++j) &#123; if (a[i] != j) //a[i]为初始值 printf(\"%c \", '.'); else //a[i]表示在第i行的第a[i]列可以放置皇后 printf(\"%c \", '#'); &#125; printf(\"\\n\"); &#125; for (i = 0; i &lt; QUEEN; ++i) printf(\"%d \", a[i]); printf(\"\\n\"); printf(\"--------------------------------\\n\");&#125;void queen() //N皇后程序&#123; int n = 0; int i = 0, j = 0; while (i &lt; QUEEN) &#123; while (j &lt; QUEEN) //对i行的每一列进行探测，看是否可以放置皇后 &#123; if(valid(i, j)) //该位置可以放置皇后 &#123; a[i] = j; //第i行放置皇后 j = 0; //第i行放置皇后以后，需要继续探测下一行的皇后位置， //所以此处将j清零，从下一行的第0列开始逐列探测 break; &#125; else &#123; ++j; //继续探测下一列 &#125; &#125; if(a[i] == INITIAL) //第i行没有找到可以放置皇后的位置 &#123; if (i == 0) //回溯到第一行，仍然无法找到可以放置皇后的位置， //则说明已经找到所有的解，程序终止 break; else //没有找到可以放置皇后的列，此时就应该回溯 &#123; --i; j = a[i] + 1; //把上一行皇后的位置往后移一列 a[i] = INITIAL; //把上一行皇后的位置清除，重新探测 continue; &#125; &#125; if (i == QUEEN - 1) //最后一行找到了一个皇后位置， //说明找到一个结果，打印出来 &#123; printf(\"answer %d : \\n\", ++n); print(); //不能在此处结束程序，因为我们要找的是N皇后问题的所有解， //此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。 j = a[i] + 1; //从最后一行放置皇后列数的下一列继续探测 a[i] = INITIAL; //清除最后一行的皇后位置 continue; &#125; ++i; //继续探测下一行的皇后位置 &#125;&#125;int main(void)&#123; init(); queen(); system(\"pause\"); return 0;&#125; 注：资料整合自网络。 ================================END==================================","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"数据结构-单循环链表代码(C++类模板封装)","slug":"数据结构-单循环链表代码-C-类模板封装","date":"2018-02-18T05:23:21.000Z","updated":"2018-02-18T05:23:59.034Z","comments":true,"path":"2018/02/18/数据结构-单循环链表代码-C-类模板封装/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-单循环链表代码-C-类模板封装/","excerpt":"","text":"循环链表就是末尾指向头形成一个循环的链表.实现思路也很简单,大体把单链表代码做个小小的改动就OK了.这次还是封装在一个类里面吧. CircleLinkList.h 类头文件,各种声明定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma once //VC防止头文件重复包含的一条预编译指令#define status bool#define OK true#define ERROR false#define YES true#define NO falsetemplate &lt;typename DType&gt;class Node&#123;public: DType data; Node * pnext;&#125;;template &lt;typename DType&gt;class CCircleLinkList&#123;private: Node&lt;DType&gt; *phead;public: CCircleLinkList(); ~CCircleLinkList();public: //初始化链表 status InitCList(); //获取链表长度 int GetCListLength(); //增加一个节点 前插法 status AddCListNodeFront(DType idata); //增加一个节点 后插法 status AddCListNodeBack(DType idata); //判断链表是否为空 status IsCListEmpty(); //获取指定位置节点值(注意，本程序规定0号为头节点，e获取删除元素) status GetCListIndexNode(DType *e, int index); //删除指定位置节点(e获取删除元素) status DeleteCListIndexNode(DType *e, int index); //查找链表中指定值(pindex获取位置0==&gt;not found) status SearchCListNode(DType SData, int *pindex); //指定位置前插 status InsertCListNodeFront(DType IData, int index); //指定位置后插 status InsertCListNodeBack(DType IData, int index); //清空链表(保留根节点) status ClearCList(); //销毁链表(all delete) status DestoryCList(); //尾部删除一个元素 status DeleteCListNodeBack(); //打印链表 此函数根据实际情况而定 void PrintCList();&#125;; CircleLinkList.cpp 类的具体实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286#include \"CircleLinkList.h\"#include &lt;stdio.h&gt;template &lt;typename DType&gt;CCircleLinkList&lt;DType&gt;::CCircleLinkList()&#123; cout &lt;&lt; \"链表创建\" &lt;&lt; endl; InitCList();&#125;template &lt;typename DType&gt;CCircleLinkList&lt;DType&gt;::~CCircleLinkList()&#123; cout &lt;&lt; \"链表销毁\" &lt;&lt; endl; DestoryCList();&#125;//初始化链表template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::InitCList()&#123; Node&lt;DType&gt; * ph = new Node&lt;DType&gt;; if (ph != NULL) &#123; ph-&gt;pnext = ph; //尾指向头 this-&gt;phead = ph; //头结点 return OK; &#125; return ERROR;&#125;//获取链表长度(head_node is not included)template &lt;typename DType&gt;int CCircleLinkList&lt;DType&gt;::GetCListLength()&#123; int length = 0; Node&lt;DType&gt; * ph = this-&gt;phead; while (ph-&gt;pnext != this-&gt;phead) &#123; length++; ph = ph-&gt;pnext; &#125; return length;&#125;//增加一个节点 前插法template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::AddCListNodeFront(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; if (pnode != NULL) &#123; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead-&gt;pnext; this-&gt;phead-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//增加一个节点 尾插法template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::AddCListNodeBack(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; Node&lt;DType&gt; * ph = this-&gt;phead; if (pnode != NULL) &#123; while (ph-&gt;pnext != this-&gt;phead) &#123; ph = ph-&gt;pnext; &#125; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead; ph-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//判断链表是否为空template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::IsCListEmpty()&#123; if (this-&gt;phead-&gt;pnext == this-&gt;phead) &#123; return YES; &#125; return NO;&#125;//获取指定位置节点值(注意，本程序规定0号为头节点，e获取节点的值)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::GetCListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; int i = 0; //计数器 if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; while (ph-&gt;pnext != this-&gt;phead) &#123; i++; ph = ph-&gt;pnext; if (i == index) &#123; *e = ph-&gt;data; return OK; &#125; &#125; return ERROR;&#125;//删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::DeleteCListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; while (ph-&gt;pnext != this-&gt;phead) &#123; i++; q = ph; //保存备用 ph = ph-&gt;pnext; if (i == index) &#123; *e = ph-&gt;data; q-&gt;pnext = ph-&gt;pnext; //删除出局 delete ph; return OK; &#125; &#125; return ERROR;&#125;//查找链表中指定值(pindex获取位置 0==&gt;not found)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::SearchCListNode(DType SData, int *pindex)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; int iCount = 0;//计数器 while (ph-&gt;pnext != this-&gt;phead) &#123; iCount++; ph = ph-&gt;pnext; if (ph-&gt;data == SData) &#123; *pindex = iCount; return YES; &#125; &#125; *pindex = 0; return NO;&#125;//指定位置前插template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::InsertCListNodeFront(DType IData, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (ph-&gt;pnext != this-&gt;phead) &#123; iCount++; q = ph; ph = ph-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = ph; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125;//指定位置后插template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::InsertCListNodeBack(DType IData, int index)&#123; Node&lt;DType&gt; * ph = this-&gt;phead; if (ph-&gt;pnext == this-&gt;phead || index &lt; 1 || index &gt; GetCListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (ph-&gt;pnext != this-&gt;phead) &#123; iCount++; q = ph; ph = ph-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = ph; ph = ph-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = ph; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125;//清空链表(保留根节点)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::ClearCList()&#123; Node&lt;DType&gt; * ph = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //防止那啥，野指针 ph = ph-&gt;pnext;//保留头节点 while (ph != this-&gt;phead) &#123; q = ph; ph = ph-&gt;pnext; delete q; //释放 &#125; this-&gt;phead-&gt;pnext = this-&gt;phead; return OK;&#125;//销毁链表(all delete)template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::DestoryCList()&#123; ClearCList(); delete this-&gt;phead;//释放头结点 return OK;&#125;template &lt;typename DType&gt;status CCircleLinkList&lt;DType&gt;::DeleteCListNodeBack()&#123; Node&lt;DType&gt; * ph = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //备用 if (ph-&gt;pnext == this-&gt;phead) &#123; return ERROR; //链表都空了还删鸡毛 &#125; while (ph-&gt;pnext != this-&gt;phead) &#123; q = ph; ph = ph-&gt;pnext; &#125; q-&gt;pnext = this-&gt;phead; delete ph; return OK;&#125;template &lt;typename DType&gt;void CCircleLinkList&lt;DType&gt;::PrintCList()&#123; Node&lt;DType&gt; * ph = this-&gt;phead; if (ph-&gt;pnext == this-&gt;phead) &#123; cout &lt;&lt; \"链表为空，打印鸡毛\" &lt;&lt; endl; return; &#125; int i = 1; cout &lt;&lt; \"===============print list================\" &lt;&lt; endl; while (ph-&gt;pnext != this-&gt;phead) &#123; ph = ph-&gt;pnext; cout &lt;&lt; \"node[\" &lt;&lt; i++ &lt;&lt; \"] = \" &lt;&lt; ph-&gt;data &lt;&lt; endl; &#125;&#125; CircleLinkListTest.cpp 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include \"CircleLinkList.h\"#include \"CircleLinkList.cpp\"using namespace std;int main()&#123; CCircleLinkList&lt;int&gt; * pMySList = new CCircleLinkList&lt;int&gt;; cout &lt;&lt; pMySList-&gt;IsCListEmpty() &lt;&lt; endl; pMySList-&gt;AddCListNodeFront(111); pMySList-&gt;AddCListNodeFront(222); pMySList-&gt;AddCListNodeFront(333); cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetCListLength() &lt;&lt; endl; pMySList-&gt;PrintCList(); pMySList-&gt;AddCListNodeBack(444); pMySList-&gt;AddCListNodeBack(555); pMySList-&gt;AddCListNodeBack(666); pMySList-&gt;PrintCList(); cout &lt;&lt; pMySList-&gt;IsCListEmpty() &lt;&lt; endl; cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetCListLength() &lt;&lt; endl; int GetElem, GetIndex; pMySList-&gt;GetCListIndexNode(&amp;GetElem, 2); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetCListIndexNode(&amp;GetElem, 6); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetCListIndexNode(&amp;GetElem, 4); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteCListIndexNode(&amp;GetElem, 1); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteCListIndexNode(&amp;GetElem, 3); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;PrintCList(); pMySList-&gt;SearchCListNode(555, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchCListNode(111, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchCListNode(666, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;InsertCListNodeFront(333, 1); pMySList-&gt;InsertCListNodeFront(444, 4); pMySList-&gt;PrintCList(); pMySList-&gt;InsertCListNodeBack(777, 3); pMySList-&gt;InsertCListNodeBack(888, 5); pMySList-&gt;PrintCList(); pMySList-&gt;DeleteCListNodeBack(); pMySList-&gt;PrintCList(); pMySList-&gt;DeleteCListNodeBack(); pMySList-&gt;PrintCList(); pMySList-&gt;DeleteCListNodeBack(); pMySList-&gt;PrintCList(); return 0;&#125; 代码未经严谨测试,如果有误,欢迎指正.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-静态链表代码(C++类模板封装)","slug":"数据结构-静态链表代码-C-类模板封装","date":"2018-02-18T05:21:42.000Z","updated":"2018-02-18T05:22:56.882Z","comments":true,"path":"2018/02/18/数据结构-静态链表代码-C-类模板封装/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-静态链表代码-C-类模板封装/","excerpt":"","text":"熬了一个下午,终于写完了.哈哈,用了C++的类模板封装了一个静态链表,简单的增删查改功能都有了.具体可以看代码: StaticLinkList.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include &lt;iomanip&gt;#define MAXSIZE 100#define status bool#define YES true#define NO false#define OK true#define ERROR falsetemplate &lt;typename DATATYPE&gt;class Component&#123;public: DATATYPE data; //数据域 int cur; //cur域，指向下一个元素的下标&#125;;template &lt;typename DATATYPE&gt;class CStaticLinkList&#123;public: Component&lt;DATATYPE&gt; StaticLinkList[MAXSIZE]; //静态表//自定义malloc和freepublic: int MallocNodeSSL(); status FreeNodeSSL(int index);public: status InitList(); //初始化静态表 status BackAddList( DATATYPE AddData); //尾增加 status InsertNodeList(DATATYPE InsertData, int index);//指定位置插入 status DeleteNodeList(DATATYPE *DelData, int index); //指定位置删除 int SearchList(DATATYPE sData); //搜索数据为sData的节点,返回其在数组中的下标,0表示失败 status GetIndexList(DATATYPE *gData, int index);//获取指定索引的节点数据 int GetLengthList(); //获取静态表的长度 status ClearList(); //清空静态表 status IsEmptyList(); //判断静态表是否为空 status IsFullList(); //判断静态表是否满了 void PrintList(); //打印静态表,此函数根据实际情况编写public: CStaticLinkList(); ~CStaticLinkList();&#125;; StaticLinkList.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#include \"StaticLinkList.h\"template &lt;typename DATATYPE&gt;CStaticLinkList&lt;DATATYPE&gt;::CStaticLinkList()&#123; cout &lt;&lt; \"===========静态表创建===========\" &lt;&lt; endl; InitList();&#125;template &lt;typename DATATYPE&gt;CStaticLinkList&lt;DATATYPE&gt;::~CStaticLinkList()&#123; cout &lt;&lt; \"===========静态表销毁===========\" &lt;&lt; endl;&#125;template &lt;typename DATATYPE&gt;int CStaticLinkList&lt;DATATYPE&gt;::MallocNodeSSL()&#123; int index = StaticLinkList[0].cur; //把备用链表第一个节点拿出来用 if (StaticLinkList[0].cur) //判断是否还有位置 &#123; StaticLinkList[0].cur = StaticLinkList[index].cur; //让备用链表第二个节点上来顶替第一个的位置 &#125; return index; //返回0表示分配失败&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::FreeNodeSSL(int index)&#123; //将删除节点挂接到备用链表上 this-&gt;StaticLinkList[index].cur = this-&gt;StaticLinkList[0].cur; this-&gt;StaticLinkList[0].cur = index; return OK;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::InitList()&#123; int i; for (i = 0; i &lt; MAXSIZE - 1; i++) &#123; StaticLinkList[i].cur = i + 1;//全部塞入备用链表 &#125; StaticLinkList[MAXSIZE - 1].cur = 0;/*因为目前静态表为空,最后一个节点的cur域为0*/ return OK;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::BackAddList(DATATYPE AddData) //尾增加&#123; if (IsFullList()) &#123; return ERROR; &#125; int index = MAXSIZE - 1; int last = index; while (index != 0) &#123; last = index; index = StaticLinkList[index].cur; &#125; int k = MallocNodeSSL(); //获取空闲位置下标 if (k) &#123; StaticLinkList[k].data = AddData; //存入数据 StaticLinkList[k].cur = 0; //末尾指向0 StaticLinkList[last].cur = k; return OK; &#125; return ERROR; &#125;//在List中第i个节点之前插入新的节点template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::InsertNodeList(DATATYPE InsertData, int index)//指定位置插入&#123; int i, GetFree, pos; pos = MAXSIZE - 1;//最后节点下标 if (index &lt; 1 || index &gt; GetLengthList() || IsFullList()) &#123; return ERROR; //位置异常处理 &#125; GetFree = MallocNodeSSL(); if (GetFree) &#123; StaticLinkList[GetFree].data = InsertData; for (i = 0; i &lt; index - 1; i++) &#123; pos = StaticLinkList[pos].cur; //定位 &#125; StaticLinkList[GetFree].cur = StaticLinkList[pos].cur; StaticLinkList[pos].cur = GetFree; //插入 int q = StaticLinkList[MAXSIZE - 1].cur; if (q == 0) //静态表为空 &#123; StaticLinkList[MAXSIZE - 1].cur = 1; &#125; return OK; &#125; return ERROR;&#125;//判断是否为空template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::IsEmptyList()&#123; if (StaticLinkList[MAXSIZE-1].cur == 0) &#123; return YES; &#125; return NO;&#125;//判断静态表是否满了template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::IsFullList()&#123; if (GetLengthList() == MAXSIZE - 2) //因为首位不存数据,因此pass掉 &#123; return YES; &#125; return NO;&#125;template &lt;typename DATATYPE&gt;int CStaticLinkList&lt;DATATYPE&gt;::GetLengthList() //获取静态表的长度&#123; int iCount = 0; int k = MAXSIZE - 1; while (StaticLinkList[k].cur != 0) &#123; iCount++; k = StaticLinkList[k].cur; &#125; return iCount;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::DeleteNodeList(DATATYPE *DelData, int index)//指定位置删除&#123; int i, pos, k; pos = MAXSIZE - 1;//最后节点下标 if (index &lt; 1 || index &gt; GetLengthList() || IsEmptyList()) &#123; return ERROR; //位置异常处理 &#125; for (i = 0; i &lt; index - 1; i++) &#123; pos = StaticLinkList[pos].cur; //定位到被删除节点的前一个节点 &#125; k = StaticLinkList[pos].cur; *DelData = StaticLinkList[k].data; //获取数据 StaticLinkList[pos].cur = StaticLinkList[k].cur;//让前一个节点直接指向后一个节点.把夹在中间的踢掉 FreeNodeSSL(k); //释放空间 return OK;&#125;//搜索数据为sData的节点,返回其在静态表中的第i个位置,0表示没找到template &lt;typename DATATYPE&gt;int CStaticLinkList&lt;DATATYPE&gt;::SearchList(DATATYPE sData)&#123; int pos = StaticLinkList[MAXSIZE-1].cur; int iCount = 1; while (pos != 0) &#123; if (StaticLinkList[pos].data == sData) //找到数据 &#123; return iCount; &#125; pos = StaticLinkList[pos].cur; //循环遍历 iCount++; &#125; return 0;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::GetIndexList(DATATYPE *gData, int index)//获取第index个节点数据&#123; int i, pos; pos = MAXSIZE - 1;//最后节点下标 if (index &lt; 1 || index &gt; GetLengthList() || IsEmptyList()) &#123; return ERROR; //位置异常处理 &#125; for (i = 0; i &lt; index; i++) &#123; pos = StaticLinkList[pos].cur; //定位到第index个节点 &#125; *gData = StaticLinkList[pos].data; return OK;&#125;template &lt;typename DATATYPE&gt;status CStaticLinkList&lt;DATATYPE&gt;::ClearList() //清空静态表&#123; InitList();//再初始化一次就是清空了 return OK;&#125;template &lt;typename DATATYPE&gt;void CStaticLinkList&lt;DATATYPE&gt;::PrintList()&#123; int pos = StaticLinkList[MAXSIZE - 1].cur; if (pos == 0) &#123; cout &lt;&lt; \"===========静态链表为空,打印鸡毛!!!===========\" &lt;&lt; endl; return; &#125; cout &lt;&lt; setiosflags(ios::left); cout &lt;&lt; setw(10) &lt;&lt; \"索引\" &lt;&lt; setw(10) &lt;&lt; \"下标\" &lt;&lt; setw(10) &lt;&lt; \"data\" &lt;&lt; setw(10) &lt;&lt; \"cur\" &lt;&lt; endl; int iCount = 1; while (pos != 0) &#123; cout &lt;&lt; setw(10) &lt;&lt; iCount &lt;&lt; setw(10) &lt;&lt; pos &lt;&lt; setw(10) &lt;&lt; StaticLinkList[pos].data &lt;&lt; setw(10) &lt;&lt; StaticLinkList[pos].cur &lt;&lt; endl; pos = StaticLinkList[pos].cur; //循环遍历 iCount++; &#125;&#125; StaticLinkListTest.cpp测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;iomanip&gt;#include \"StaticLinkList.h\"#include \"StaticLinkList.cpp\"using namespace std;int main()&#123; char get; CStaticLinkList&lt;char&gt; *p = new CStaticLinkList&lt;char&gt;; p-&gt;PrintList(); p-&gt;BackAddList('a'); //pass p-&gt;BackAddList('b'); p-&gt;BackAddList('c'); p-&gt;BackAddList('d'); p-&gt;BackAddList('e'); //p-&gt;ClearList(); //pass p-&gt;PrintList(); p-&gt;DeleteNodeList(&amp;get, 2); //pass cout &lt;&lt; \"get = \" &lt;&lt; get &lt;&lt; endl; p-&gt;DeleteNodeList(&amp;get, 2); cout &lt;&lt; \"get = \" &lt;&lt; get &lt;&lt; endl; p-&gt;PrintList(); p-&gt;BackAddList('f'); p-&gt;PrintList(); cout &lt;&lt; \"length = \" &lt;&lt; p-&gt;GetLengthList() &lt;&lt; endl;//pass p-&gt;GetIndexList(&amp;get, 3); //pass cout &lt;&lt; \"get = \" &lt;&lt; get &lt;&lt; endl; p-&gt;InsertNodeList('h', 2); p-&gt;InsertNodeList('i', 3); p-&gt;PrintList(); cout &lt;&lt; \"length = \" &lt;&lt; p-&gt;GetLengthList() &lt;&lt; endl;//pass cout &lt;&lt; \"search_pos = \" &lt;&lt; p-&gt;SearchList('q') &lt;&lt; endl; cout &lt;&lt; \"search_pos = \" &lt;&lt; p-&gt;SearchList('h') &lt;&lt; endl; cout &lt;&lt; \"search_pos = \" &lt;&lt; p-&gt;SearchList('i') &lt;&lt; endl; delete p; return 0;&#125; 运行结果 代码未经过严谨测试,如果有错,欢迎大家指正和交流啊.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-线性表|顺序表|链表(中)","slug":"数据结构-线性表-顺序表-链表-中","date":"2018-02-18T05:19:16.000Z","updated":"2018-02-18T05:19:55.802Z","comments":true,"path":"2018/02/18/数据结构-线性表-顺序表-链表-中/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-线性表-顺序表-链表-中/","excerpt":"","text":"数据结构-线性表|顺序表|链表(中)本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list)03 单链表(Singly Linked List )3.1 什么是单链表？单链表是一种链式存储的结构。它动态的为节点分配存储单元。当有节点插入时，系统动态的为结点分配空间。在结点删除时，应该及时释放相应的存储单元，以防止内存泄露。由于是链式存储，所以操作单链表时，必须知道头结点或者头指针的位置。并且，在查找第i个节点时，必须找到第i-1个节点。 3.2 单链表的存储结构代码描述对于链式存储，通过上一节的讲解相信大家已经了解得够清楚了。如下图所示： 下面我们来看看单链表存储是如何用代码来实现的。123456//单链表的存储结构C语言代码typedef struct SListNode&#123; datatype data; //数据域 struct SListNode * pnext;//指针域&#125;SLinkList; 由上面的结构我们可以看出，一个节点由存放数据的数据域和存放地址的指针域组成。假如p指向了第i个节点，那么p-&gt;data就是该节点存放的数据，而p-&gt;pnext自然就是指向下一个节点的指针。如下图所示： 那么接下来我们看看单链表的各个操作具体实现吧。(只讲几个关键步骤)备注：下面的代码基于这样的一个单链表： 有一个头指针phead 有一个头结点node 头指针指向头结点，头结点位置记为03.3 单链表的读取在拿到头指针以后，单链表的读取也并非一件难事。一开始设置一个计数变量，不断遍历链表，让计数器自增。找到合适的位置将数据读取出来。具体代码实现如下：12345678910111213141516171819202122232425262728#define status bool#define ERROR false#define OK true/* * 函数功能：获取位置index节点的数据 * 参数说明：phead链表头结点，e用来获取的变量，index索引*/status GetSListIndexNode(Node * phead,DType *e, int index)&#123; int icount = 0; //计数器 //注：0号位为头结点，头结点不存放任何数据 if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()/*此处为链表长度*/) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; icount++; phead = phead-&gt;pnext; if (icount == index) &#123; *e = phead-&gt;data; return OK; &#125; &#125; return ERROR;&#125; 3.4 单链表的插入3.4.1 指定位置后插其实链表的插入和删除都是很简单的操作，初学者只要抓住指针指向的节点，并加以区分开来，就很easy了。如下图： 图中，假如此时p指向了我们要插入的节点的位置。那么，怎样把我们的S节点给插入到p指向的节点之后？在这里我们先不要惊动p以及p后面的节点： 我们先让S节点指向p之后的节点(步骤①) 之后我们切断p和p后面那个节点的关系(步骤②) 最后让p节点的指针域指向s节点(步骤③)，搞定 算法描述： 声明一个指针p指向链表头结点，向后遍历p=p-&gt;next，找到正确的位置。 新建一个结点s。 s-&gt;next = p-&gt;next ① p-&gt;next = s ②③具体代码如下：12345678910111213141516171819202122232425262728293031#define status bool#define ERROR false#define OK true/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData插入的数据，index索引*/status InsertSListNodeFront(Node * phead, DType IData, int index)&#123; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if ( iCount == index ) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125; 3.4.1 指定位置前插咳咳，聪明的小伙伴，用脑子想想。指定位置前插 == 指定位置的前一个位置进行后插。懂了吧？直接看具体代码：123456789101112131415161718192021222324252627282930/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData插入的数据，index索引*/status InsertSListNodeBack(Node * phead, DType IData, int index)&#123; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = phead; phead = phead-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125; 3.5 单链表的删除单链表的删除其实也是很简单。只要比如要删除p指向的节点，只需要让p之前的节点的指针域直接指向p之后的节点，再把p给free就OK了。如下图： 算法描述: 声明一个指针p指向链表头结点，向后遍历p=p-&gt;next，找到要删除的节点位置。 q = p-&gt;next p-&gt;next = q-&gt;next ①② free(q) ③④ 具体代码如下:12345678910111213141516171819202122232425262728/* * 函数功能：指定位置后插 * 参数说明：phead链表头结点，IData获取删除的数据，index索引*///删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status DeleteSListIndexNode(Node * phead, DType *e, int index)&#123; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; q = phead; //保存备用 phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; q-&gt;pnext = phead-&gt;pnext; //删除出局 return OK; &#125; &#125; return ERROR;&#125; 代码应该不难，相信大家都能很容易看懂。 3.6 单链表的完整代码好了，前面介绍了几个重要的操作，接下来请大家看看完整的代码吧。小编为了使用方便，就用C++的class和template将整个链表封装到了一个类里面，通过模板实现泛型编程。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415/* * 文件名:SingleLinkList.h * 说明 ：类的各种声明 */#pragma once //VC编译器防止头文件被重复包含的一条预编译指令#define status bool#define OK true#define ERROR false#define YES true#define NO falsetemplate &lt;typename DType&gt;class Node&#123;public: DType data; Node * pnext;&#125;;template &lt;typename DType&gt;class CSingleLinkList&#123;private: Node&lt;DType&gt; *phead; //链表头指针public: CSingleLinkList();//构造，类被创建时调用 ~CSingleLinkList();//析构，类被销毁时调用public: //初始化链表 status InitSList(); //获取链表长度 int GetSListLength(); //增加一个节点 前插法 status AddSListNodeFront(DType idata); //增加一个节点 后插法 status AddSListNodeBack( DType idata); //判断链表是否为空 status IsSListEmpty(); //获取指定位置节点值(注意，本程序规定0号为头节点，e获取删除元素) status GetSListIndexNode(DType *e, int index); //删除指定位置节点(e获取删除元素) status DeleteSListIndexNode(DType *e, int index); //查找链表中指定值(pindex获取位置0==&gt;not found) status SearchSListNode(DType SData, int *pindex); //指定位置前插 status InsertSListNodeFront(DType IData, int index); //指定位置后插 status InsertSListNodeBack(DType IData, int index); //清空链表(保留根节点) status ClearSList(); //销毁链表(all delete) status DestorySList(); //尾部删除一个元素 status DeleteSListNodeBack(); //打印链表 此函数根据实际情况而定 void PrintSList();&#125;;/* * 文件名:SingleLinkList.cpp * 说明 ：类的各种方法的实现 */#include \"SingleLinkList.h\"#include &lt;stdio.h&gt;template &lt;typename DType&gt;CSingleLinkList&lt;DType&gt;::CSingleLinkList()&#123; cout &lt;&lt; \"链表创建\" &lt;&lt; endl; InitSList();&#125;template &lt;typename DType&gt;CSingleLinkList&lt;DType&gt;::~CSingleLinkList()&#123; cout &lt;&lt; \"链表销毁\" &lt;&lt; endl; DestorySList();&#125;//初始化链表template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InitSList()&#123; Node&lt;DType&gt; * ph = new Node&lt;DType&gt;; if (ph != NULL) &#123; ph-&gt;pnext = nullptr; this-&gt;phead = ph; //头结点 return OK; &#125; return ERROR;&#125;//获取链表长度(head_node is not included)template &lt;typename DType&gt;int CSingleLinkList&lt;DType&gt;::GetSListLength()&#123; int length = 0; Node&lt;DType&gt; * phead = this-&gt;phead; while (phead-&gt;pnext != nullptr) &#123; length++; phead = phead-&gt;pnext; &#125; return length;&#125;//增加一个节点 前插法template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::AddSListNodeFront( DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; if (pnode != NULL) &#123; pnode-&gt;data = idata; pnode-&gt;pnext = this-&gt;phead-&gt;pnext; this-&gt;phead-&gt;pnext = pnode; //挂载 //printf(\"pnode = %p pnode-&gt;pnext = %p this-&gt;phead-&gt;pnext = %p this-&gt;phead = %p\\n\", pnode, pnode-&gt;pnext, this-&gt;phead-&gt;pnext, this-&gt;phead); return OK; &#125; return ERROR;&#125;//增加一个节点 尾插法template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::AddSListNodeBack(DType idata)&#123; Node&lt;DType&gt; * pnode = new Node&lt;DType&gt;; Node&lt;DType&gt; * phead = this-&gt;phead; if (pnode != NULL) &#123; while (phead-&gt;pnext != nullptr) &#123; phead = phead-&gt;pnext; &#125; pnode-&gt;data = idata; pnode-&gt;pnext = nullptr; phead-&gt;pnext = pnode; //挂载 return OK; &#125; return ERROR;&#125;//判断链表是否为空template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::IsSListEmpty()&#123; if (this-&gt;phead-&gt;pnext == nullptr) &#123; return YES; &#125; return NO;&#125;//获取指定位置节点值(注意，本程序规定0号为头节点，e获取节点的值)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::GetSListIndexNode(DType *e, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int i = 0; //计数器 if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; return OK; &#125; &#125; return ERROR;&#125;//删除指定位置节点(e获取删除元素)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DeleteSListIndexNode( DType *e, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int i = 0; //计数器 Node&lt;DType&gt; * q = nullptr; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; while (phead-&gt;pnext != nullptr) &#123; i++; q = phead; //保存备用 phead = phead-&gt;pnext; if (i == index) &#123; *e = phead-&gt;data; q-&gt;pnext = phead-&gt;pnext; //删除出局 return OK; &#125; &#125; return ERROR;&#125;//查找链表中指定值(pindex获取位置 0==&gt;not found)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::SearchSListNode( DType SData, int *pindex)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; int iCount = 0;//计数器 while (phead-&gt;pnext != nullptr) &#123; iCount++; phead = phead-&gt;pnext; if (phead-&gt;data == SData) &#123; *pindex = iCount; return YES; &#125; &#125; *pindex = 0; return NO;&#125;//指定位置前插template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InsertSListNodeFront(DType IData, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if ( iCount == index ) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; //前插 return OK; &#125; &#125; return ERROR;&#125;//指定位置后插template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::InsertSListNodeBack( DType IData, int index)&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || index &lt; 1 || index &gt; GetSListLength()) &#123; return ERROR; //异常 处理 &#125; int iCount = 0; //计数器 Node&lt;DType&gt; * q = nullptr; //备用 while (phead-&gt;pnext != nullptr) &#123; iCount++; q = phead; phead = phead-&gt;pnext; if (iCount == index) &#123; Node&lt;DType&gt; * p = new Node&lt;DType&gt;; q = phead; phead = phead-&gt;pnext; //后插就是后一个节点的前插咯 p-&gt;data = IData; p-&gt;pnext = phead; q-&gt;pnext = p; return OK; &#125; &#125; return ERROR;&#125;//清空链表(保留根节点)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::ClearSList()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //防止那啥，野指针 phead = phead-&gt;pnext;//保留头节点 while (phead != nullptr) &#123; q = phead; phead = phead-&gt;pnext; delete q; //释放 &#125; this-&gt;phead-&gt;pnext = nullptr; return OK;&#125;//销毁链表(all delete)template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DestorySList()&#123; ClearSList(); delete this-&gt;phead;//释放头结点 return OK;&#125;template &lt;typename DType&gt;status CSingleLinkList&lt;DType&gt;::DeleteSListNodeBack()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; Node&lt;DType&gt; * q = nullptr; //备用 if (phead-&gt;pnext == nullptr) &#123; return ERROR; //链表都空了还删鸡毛 &#125; while (phead-&gt;pnext != nullptr) &#123; q = phead; phead = phead-&gt;pnext; &#125; q-&gt;pnext = nullptr; delete phead; return OK; &#125;template &lt;typename DType&gt;void CSingleLinkList&lt;DType&gt;::PrintSList()&#123; Node&lt;DType&gt; * phead = this-&gt;phead; if (phead-&gt;pnext == nullptr || phead == nullptr) &#123; cout &lt;&lt; \"链表为空，打印鸡毛\" &lt;&lt; endl; return; &#125; int i = 1; cout &lt;&lt; \"===============print list================\" &lt;&lt; endl; while (phead-&gt;pnext != nullptr) &#123; phead = phead-&gt;pnext; cout &lt;&lt;\"node[\" &lt;&lt; i++ &lt;&lt; \"] = \" &lt;&lt; phead-&gt;data&lt;&lt;endl; &#125;&#125;/* * 文件名:SingleLinkListTest.cpp * 说明 ：测试代码 */ #include &lt;iostream&gt;#include \"SingleLinkList.h\"#include \"SingleLinkList.cpp\"using namespace std;int main()&#123; CSingleLinkList&lt;int&gt; * pMySList = new CSingleLinkList&lt;int&gt;; cout &lt;&lt; pMySList-&gt;IsSListEmpty() &lt;&lt; endl; pMySList-&gt;AddSListNodeFront(111); pMySList-&gt;AddSListNodeFront(222); pMySList-&gt;AddSListNodeFront(333); cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetSListLength() &lt;&lt; endl; pMySList-&gt;PrintSList(); pMySList-&gt;AddSListNodeBack(444); pMySList-&gt;AddSListNodeBack(555); pMySList-&gt;AddSListNodeBack(666); pMySList-&gt;PrintSList(); cout &lt;&lt; pMySList-&gt;IsSListEmpty() &lt;&lt; endl; cout &lt;&lt; \"链表长度\" &lt;&lt; pMySList-&gt;GetSListLength() &lt;&lt; endl; int GetElem, GetIndex; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 2); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 6); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;GetSListIndexNode(&amp;GetElem, 4); cout &lt;&lt; \"Got Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteSListIndexNode(&amp;GetElem, 1); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;DeleteSListIndexNode(&amp;GetElem, 3); cout &lt;&lt; \"del Elem = \" &lt;&lt; GetElem &lt;&lt; endl; pMySList-&gt;PrintSList(); pMySList-&gt;SearchSListNode(555, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchSListNode(111, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;SearchSListNode(666, &amp;GetIndex); cout &lt;&lt; \"Search Index = \" &lt;&lt; GetIndex &lt;&lt; endl; pMySList-&gt;InsertSListNodeFront(333, 1); pMySList-&gt;InsertSListNodeFront(444, 4); pMySList-&gt;PrintSList(); pMySList-&gt;InsertSListNodeBack(777, 3); pMySList-&gt;InsertSListNodeBack(888, 5); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); pMySList-&gt;DeleteSListNodeBack(); pMySList-&gt;PrintSList(); return 0;&#125;代码如果有不正确的地方，欢迎大家来指正哈。 04 静态链表(circular linked list)4.1 什么是静态链表？我们把线性表的元素存放在数组中，这些元素由两个域组成： 数据域data 指针域cur 数据域是存放数据的，而指针域，这里和链表不同是，它存的不再是指向下一个节点的内存地址。而是下一个节点在数组中的下标。我们就把这种用数组描述的链表称为静态表，该方法也称之为游标实现法。如下图所示： 由上图我们需要注意以下几点： 我们对数组的第一个元素和最后一个元素做特殊处理，不存放数据。 把未使用的数组元素称为备用链表。 数组的第一个元素(下标为0)的cur域存放备用链表第一个节点的下标。 数组的最后一个元素的cur域存放第一个有数据的节点的下标，相当于链表中头结点的存在。链表为空时，其值为0。 如下图： 引出的问题：数组的长度定义的问题，无法预支。所以，为了防止溢出，我们一般将静态表开得大一点。 4.2 静态链表存储的代码描述基于上面的讲解，我们来看看代码是怎么描述这种存储结构的。1234567//---------线性表的静态单链表存储结构--------#define MAXSIZE 1000 /*假设链表最大长度为1000*/typedef struct&#123; datatype data; int cur; //为0时表示无指向&#125;SLinkList[MAXSIZE]; 接下来我们讲解几个重要的操作实现。 4.3 静态链表的插入操作前面我们讲动态链表的时候说过，增加和删除一个节点我们可以用malloc()和free()函数(C++可用new和delete)来实现。但是现在由于我们操作的是静态表，它可是用数组存的，可没有这种操作了。因此我们首先来自己实现一个静态表的malloc和free。 那么怎么辨别数组中哪些空间没有被使用呢？一个好的解决办法是，将所有未使用或者被删除的空间串成一个备用链表。插入节点时便可以从备用链表获取第一个未使用的空间的下标。因此我们在初始化的时候会做这样的工作： 12345678910void SListInit(SLinkList space)&#123; int i; for(i = 0; i &lt; MAXSIZE; i++) space[i].cur = i+1; //将所有结点链入备用链表 //备用链表头指针链像第二个结点 space[0].cur = space[1].cur; //第一个结点作为链表的头结点 space[1].cur = 0; &#125; 分配内存123456789101112/分配备用链表的一个结点,返回下标//若为0，则说明备用链表用完int Malloc_SL(SLinkList space)&#123; int i = space[0].cur; //判断备用链表是否非空 if(space[0].cur) //备用链表头指针指向第二个空结点 space[0].cur = space[i].cur; return i; //返回第一个空结点&#125; 上面的代码应该是没有难度的。写完了这个函数，我们来看看静态表中具体如何插入：12345678910111213141516171819//在链表的第i个位置插入元素evoid SlistInsert(SLinkList space, int i, ElemType e)&#123; //超出范围 if(i &lt; 1 || i &gt; SListLength(space)+1) return; int k = 1, j; //使k指示要插入的结点的前一个结点 for(j = 0; j &lt;i-1; j++) k = space[k].cur; int v = Malloc_SL(space); if(v) //如果有空间 &#123; space[v].data = e; space[v].cur = space[k].cur; space[k].cur = v; //链入链表 &#125;&#125; 注意几点： 首先我们让k指向了要插入节点(记为X)的前一个位置(记为Y节点)，前插法。 然后我们在静态表内申请空间，存放新的节点(记为N)。 把数据放进新申请的节点里面。 新节点N的cur域指向X节点，然后让Y节点指向N节点。 该过程不难理解。就不上图了…… 4.4 静态链表的删除操作删除同样需要自己实现free函数，我们来看看代码： 回收内存12345678//将下标为k的空闲结点回收到备用链表void Free_SL(SLinkList space, int k)&#123; //将备用链表链到k之后 space[k].cur = space[0].cur; //将k链到备用链表头之后 space[0].cur = k; &#125; 删除以后记得把空间重新挂载到备用链表上以便下一次使用。下面我们实现删除的代码： 1234567891011121314//删除第i个位置的元素void SListDelete(SLinkList space, int i)&#123; //超出范围退出 if(i &lt; 1 || i &gt; SListLength(space)) return ; int k = 1, j; //使k指示要删除的结点的前一个结点 for(j = 0; j &lt;i-1; j++) k = space[k].cur; int temp = space[k].cur; space[k].cur = space[temp].cur; Free_SL(space, temp);&#125; 其实代码也很好理解了。假如X、Y、Z……等等排列，我们要删除Y。无非就是告诉X，你不要指向Y了，你直接指向Z，然后我们再把Y给free了。就直接变成了X、Z……简单吧。 4.5 静态链表的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194/************************************* 静态链表数据结构：每个数组节点都有值和游标.游标表示下一个节点，节点分为已用节点和备用节点第一个节点和最后节点保留：第一个节点游标表示备用节点起始位置最后一个节点游标表示已用节点的起始位置已用节点的最后一个元素的游标指向0，表示末尾。*************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#define ERROR 0#define OK 1#define MAX 100 //声明数组的最大长度typedef int Status,ElemType;typedef struct&#123; int data; //数据 int cur; //游标&#125;component,staticlink[MAX]; //定义结构体数组/********************************** 初始化链表输入值：链表的指针输出值：状态码功能： 将所以节点的游标指向后一个节点 ***********************************/Status initLink(staticlink space)&#123; int i; for(i=0;i&lt;(MAX-1);i++)&#123; //遍历所有节点 space[i].cur = i+1; //将节点的游标指向下个节点 &#125; space[MAX-1].cur = 0; //最后一个节点的游标指向第一个节点 return OK;&#125;/********************************* 分配备用空间输入值：链表的指针输出值：备用节点的下标功能： 将备用节点的分配出来使用 *********************************/int mallocSpace(staticlink space)&#123; int i; i = space[0].cur; //取出第一个备用节点 if(space[0].cur) //如果取出成功 space[0].cur = space[i].cur; //第一个节点的指针往后移动 return i;&#125;/******************************** 获取长度输入值：链表的指针输出值：长度值功能： 将链表中已用的节点个数返回 ********************************/int getLength(staticlink space)&#123; int mov = MAX-1; int j=0; while(space[mov].cur) &#123; //遍历所有已用节点 mov = space[mov].cur; j++; &#125; return j;&#125;/********************************* 创建值输入值：链表的指针，初始值个数输出值：状态码功能： 为链表初始指定个数的随机值 *********************************/Status createValue(staticlink space,int num)&#123; srand(time(0)); int i,mov = MAX-1; space[mov].cur = 1; for(i=0;i&lt;num;i++) &#123; mov = space[mov].cur; //移动游标 space[mov].data = rand()%100+1; //初始化随机值 &#125; space[0].cur = space[mov].cur;//第一节点游标指向备用节点 space[mov].cur = 0; //最后一个已用节点指向第一个节点 return OK;&#125;/********************************* 插入节点输入值：链表的指针，插入位置(从1开始)，插入位置输出值：状态码功能： 在指定的位置插入指定的值 *********************************/Status insertNode(staticlink space,int index,ElemType e)&#123; int new,mov,i; if(index&lt;1 || index&gt;getLength(space))return ERROR; //不可以超过已用节点个数 mov = MAX-1; new = mallocSpace(space); if(new)&#123; space[new].data=e; //创建新节点 for(i=1;i&lt;index;i++)//定位插入节点的前一节点 mov = space[mov].cur; space[new].cur = space[mov].cur; //连后 space[mov].cur = new; //接前 return OK; &#125; return ERROR;&#125;/************************************ 删除节点输入值：链表的指针，删除位置(从1开始)输出值：状态码功能： 删除指定的节点 ************************************/Status deleteNode(staticlink space,int index)&#123; if(index&lt;1 || index&gt;getLength(space))return ERROR; int mov,next,i; mov = MAX-1; for(i=1;i&lt;index;i++) //定位删除节点的前一节点 mov = space[mov].cur; next = space[mov].cur;//获取被删节点 space[mov].cur = space[next].cur; //前一节点连接被删节点的游标 freeNode(space,next);//释放被删节点 return OK;&#125;/*********************************** 释放节点输入值：链表的指针，释放节点的位置输出值：状态码功能: 将已用节点释放成备用节点 ***********************************/Status freeNode(staticlink space,int target)&#123; space[target].cur = space[0].cur;//释放节点连接第一备用节点 space[0].cur = target;//第一节点连接释放节点 return OK;&#125;/********************************** 输出链表输入值：链表的指针输出值：状态码功能： 将链表的值一一输出 **********************************/Status printLink(staticlink space)&#123; int mov = MAX-1; while(space[mov].cur) &#123; mov = space[mov].cur; printf(\"[%d] \",space[mov].data); &#125; printf(\"\\n\"); return OK;&#125;int main()&#123; int num,value,index; staticlink L; initLink(L); printf(\"[create]enter num:\"); scanf(\"%d\",&amp;num); createValue(L,num); printLink(L); printf(\"[insert]enter index:\"); scanf(\"%d\",&amp;index); printf(\"[insert]enter value:\"); scanf(\"%d\",&amp;value); insertNode(L,index,value); printLink(L); printf(\"[delete]enter index:\"); scanf(\"%d\",&amp;index); deleteNode(L,index); printLink(L); return 0; 这次就先到这里吧。更多精彩内容，请期待下回分解。 另外：部分资料参考自网络，来源和作者实在无法考证，如果有侵犯到您的劳动成果，请速与我联系。 ========================END=======================","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构-线性表|顺序表|链表(上)","slug":"数据结构-线性表-顺序表-链表-上","date":"2018-02-18T05:14:40.000Z","updated":"2018-02-18T05:17:28.301Z","comments":true,"path":"2018/02/18/数据结构-线性表-顺序表-链表-上/","link":"","permalink":"http://yoursite.com/2018/02/18/数据结构-线性表-顺序表-链表-上/","excerpt":"","text":"本节纲要 预备知识 顺序表(Sequential List) 单链表(Singly Linked List ) 静态链表(Static list ) 循环链表(circular linked list) 双向链表(doubly linked list) 01 预备知识1.0 什么是线性表?线性表(List)是零个或者多个数据元素的有限序列. 首先它是一个序列.里面的元素是有顺序的,如果有多个元素,除开头和结尾以外的元素都有一个前驱和一个后继.而开头元素只有后继,结尾元素只有前驱. 其次线性表是有限的，也就是里面的元素个数是有限的。 1.1 线性表的基本操作(描述)12345678910111213ADT 线性表（List）Data 线性表的数据对象集合为&#123;a1, a2, a3, ......, an&#125;,每个元素类型为DataType。Operation InitList(L); //初始化线性表 IsEmptyList(L); //判断线性表是否为空 ClearList(L); //清空线性表 GetElemList(L, i, *e); //获取第i个位置的数据 SearchList(L, e); //查找与数据e相等的元素 InsertNodeList(L, i, e);//在第i个位置插入元素 DeleteNodeList(L, i, *e);//删除第i个位置的元素，e获取删除元素 GetLengthList(L); //获取线性表的长度endADT 关于线性表的基本操作就上面几种，还有几个例如线性表的排序，合并，逆序等等操作。为了文章篇幅，就下次再介绍了。 1.2 什么是顺序存储结构?线性表的顺序存储结构，就是指 用一段地址连续的存储单元一次存储线性表的数据元素。学过高级语言的朋友，相信对数组这玩意儿都不会陌生吧。数组就是一种顺序存储结构。 1.3 什么是链式存储结构?链式存储结构就是可以用一组任意的内存单元存储线性表中的元素。与顺序存储不同的是，这组内存单元可以是连续的，也可以是不连续的。这就意味着，元素可以存储在内存的任意位置。正因为如此，在链式结构中，每个元素不仅要存它的信息，还需要存储它后继元素的存储地址。我们把存储元素信息的域称为数据域，而把存储后继元素地址的域称为指针域。由这两部分共同组成的数据元素ai，则可以称之为节点(Node)。如下面这个图所示： 1.5 什么是链表?链表就是链式存储的线性表。结点之间通过逻辑连接，形成链式存储结构。存储结点的内存单元，可以是连续的也可以是不连续的。逻辑连接与物理存储次序没有关系。 02 顺序表(Sequential List)2.0 什么是顺序表? 采用顺序存储结构的线性表，就是顺序表。 2.1 顺序表的存储结构代码这里我们统一采用C语言来描述。1234567#define MAXSIZE 20 //存储空间的初始大小typedef int DataType //类型可根据实际情况而定typedef struct &#123; DataType data[MAXSIZE]; //数组来存储数据 int length; //实际长度&#125;SqlList; 可见，顺序表的几个重要特性： 存储空间的位置：数组data 顺序表的最大容量：数组长度MAXSIZE 顺序表当前长度：length 2.2 顺序表的插入操作相信大家在排队的时候都有过被插队的体验吧。当一个插队到你前面时，这个时候你内心os mmp外加素质三连的同时，也不得不往后挪一个位置。于是乎这个就不得了了，你后面的也要往后挪，你后面的后面也是……然后队伍里瞬间就狼烟起……那么，这个顺序表的插入其实也差不多的。由于地址是连续存储的，那么在某个地方插入以后，其后的元素不得不往后挪一个位置。 插入算法描述： 异常处理(插入位置不合理、顺序表已经满等等)。抛出异常。 从最后一个元素往前遍历到第i个位置，依次将他们都往后挪一个位置。 将要插入的元素放入位置i处。 别忘记了表长度length++。 由于数组下标是从0开始的，我们习惯要删除的位置第i处又是从1开始算起的。本文就全部统一成，都从0开始吧。比如要在第5个位置插入一个元素，那就是a[5]。不然真的会混乱的。 具体代码如下：1234567891011121314151617//功能：在顺序表L第i个位置之前插入元素eint InsertSqlList(SqlList *L, int i, DataType data)&#123; int k; if(L-&gt;length==MAXSIZE || i&lt;0 || i&gt;L-&gt;length) //记住，都是从0开始的哦 return 0;//异常处理 if(i == L-&gt;length) L-&gt;data[length++] = data;//尾插一步到位 if(i &lt; L-&gt;length) //中间插，要挪人啦 &#123; for(k = L-&gt;length-1; k &gt;= i;k--) //再次强调哈，都是从0开始的。 L-&gt;data[k+1]=L-&gt;data[k];//后移 L-&gt;data[i] = data;//新元素插入 L-&gt;length++; &#125; return 1;&#125; 2.2 顺序表的删除操作算法描述： 异常处理(删除位置不合理、顺序表为空等等) 尾删，直接获取然后length–。 中间删，从i开始往后遍历，依次将各元素往前挪。e获取要删元素，length–即可。12345678910111213141516171819//功能：在顺序表L中删除第i个数据元素，用e获取被删除值int DeleteElemList(SqlList *L, int i, DataType *e)&#123; int k; if(L-&gt;length==0 || i&lt;0 || i&gt;L-&gt;length-1) //记住，都是从0开始的哦 return 0;//异常处理 if(i == L-&gt;length-1) //尾删，easy &#123; *e = L-&gt;data[i];//获取要删除元素 L-&gt;length--; //删除元素 &#125; if(i &lt; L-&gt;length) //中间删，要挪人啦 &#123; *e = L-&gt;data[i];//获取要删除元素 for(k = i; k &lt; L-&gt;length-1;k++) //再次强调哈，都是从0开始的。 L-&gt;data[k]=L-&gt;data[k+1];//前移 L-&gt;length--; return 1; &#125; 2.3 顺序表的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 20#define ERROR 0#define OK 1#define NO 0#define YES 1typedef int DataType;typedef int Status;typedef struct List&#123; int data[MAXSIZE]; int length;&#125;SqlList;void InitList(SqlList * L); //初始化顺序表Status IsEmptyList(SqlList *L); //判断顺序表是否为空void ClearList(SqlList *L); //清空线性表Status GetElemList(SqlList *L,int i,DataType *e); //获取第i个位置的数据int SearchList(SqlList *L, DataType e); //查找与数据e相等的元素Status InsertNodeList(SqlList *L, int i,DataType e);//在第i个位置插入元素Status DeleteNodeList(SqlList *L, int i, DataType *e);//删除第i个位置的元素，e获取删除元素int GetLengthList(SqlList *L); //获取线性表的长度void PrintList(SqlList *L); //遍历顺序表,此函数测试使用，根据实际类型编写int main()&#123; int e; SqlList *pL = (SqlList*)malloc(sizeof(SqlList)); InitList(pL); InsertNodeList(pL, 0, 1); InsertNodeList(pL, 1, 2); InsertNodeList(pL, 2, 3); InsertNodeList(pL, 3, 4); InsertNodeList(pL, 4, 5); InsertNodeList(pL, 5, 6); PrintList(pL); DeleteNodeList(pL, 2, &amp;e); DeleteNodeList(pL, 4, &amp;e); PrintList(pL); return 0;&#125;void InitList(SqlList * L)&#123; for(int i = 0; i &lt; MAXSIZE; i++) L-&gt;data[i] = 0; L-&gt;length = 0; //将表设为空&#125;Status IsEmptyList(SqlList *L)&#123; if(L-&gt;length == 0) return YES;//表为空 else return NO;&#125;void ClearList(SqlList *L)&#123; InitList(L);//此操作跟初始化一样。&#125;//这里的第i个位置，为了统一我们也是从0算起的Status GetElemList(SqlList *L,int i,DataType *e)&#123; if(i &lt; 0 || i &gt;= L-&gt;length || L-&gt;length == 0) return ERROR;//异常处理 *e = L-&gt;data[i]; return OK;&#125;//找到与数据e相同的节点，返回下标。-1表示没找到,ERROR表示表为空int SearchList(SqlList *L, DataType e)&#123; if(L-&gt;length == 0) return ERROR; for(int i = 0; i &lt; L-&gt;length; i++) &#123; if(L-&gt;data[i] == e) return i; &#125; return -1;&#125;//获取顺序表的长度int GetLengthList(SqlList *L)&#123; return L-&gt;length;&#125;//在位置i插入元素，再次强调，从0开始Status InsertNodeList(SqlList *L, int i,DataType e)&#123; if(i &lt; 0 || i &gt; L-&gt;length || L-&gt;length == MAXSIZE) return ERROR;//异常处理 for(int k = L-&gt;length; k &gt; i; k--) &#123; L-&gt;data[k] = L-&gt;data[k-1]; //往后挪 &#125; L-&gt;data[i] = e;//插入数据， L-&gt;length++; //长度也要加1 return OK;&#125;Status DeleteNodeList(SqlList *L, int i, DataType *e)&#123; if(i &lt; 0 || i &gt; L-&gt;length || L-&gt;length == 0) return ERROR;//异常处理 *e = L-&gt;data[i];//获取数据 for(int k = i; k &lt; L-&gt;length -1; k++) L-&gt;data[k] = L-&gt;data[k+1];//往前挪 L-&gt;length--; //长度减1 return OK;&#125;void PrintList(SqlList *L)&#123; if(L-&gt;length == 0) &#123; printf(\"顺序表为空\\n\"); &#125; printf(\"============遍历顺序表如下=============\\n\"); for(int i = 0; i &lt; L-&gt;length; i++) &#123; printf(\"\\tdata[%d] = %d\\n\", i, L-&gt;data[i]); &#125; printf(\"============共计%d个元素=============\\n\", L-&gt;length);&#125; 纯手打哈。。简单测试了一下。如果存在问题，欢迎指正，谢谢大家。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"test","slug":"324","date":"2018-02-15T16:51:23.000Z","updated":"2018-02-15T16:53:11.477Z","comments":true,"path":"2018/02/16/324/","link":"","permalink":"http://yoursite.com/2018/02/16/324/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](https://hexo.io/docs/deploy","categories":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}],"tags":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/tags/Python全栈/"}],"keywords":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}]},{"title":"test","slug":"2123","date":"2018-02-15T16:51:23.000Z","updated":"2018-02-15T16:53:11.477Z","comments":true,"path":"2018/02/16/2123/","link":"","permalink":"http://yoursite.com/2018/02/16/2123/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](https://hexo.io/docs/deploy","categories":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}],"tags":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/tags/Python全栈/"}],"keywords":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}]},{"title":"test","slug":"test","date":"2018-02-15T16:51:23.000Z","updated":"2018-02-15T16:53:11.477Z","comments":true,"path":"2018/02/16/test/","link":"","permalink":"http://yoursite.com/2018/02/16/test/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](https://hexo.io/docs/deploy","categories":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}],"tags":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/tags/Python全栈/"}],"keywords":[{"name":"Python全栈","slug":"Python全栈","permalink":"http://yoursite.com/categories/Python全栈/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-15T13:34:33.765Z","updated":"2018-02-15T13:34:33.765Z","comments":true,"path":"2018/02/15/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}